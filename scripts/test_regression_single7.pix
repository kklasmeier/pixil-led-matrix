# Surface Tension - Water Droplet Merging and Surface Tension Effects
# Simulates water droplets with realistic physics: formation, movement, merging, and surface tension

clear()

# Configuration
v_max_droplets = 12
v_surface_y = 50  # Water surface level
v_gravity = 0.15
v_surface_tension_strength = 2.0
v_merge_distance = 8

# Create arrays for droplet properties
create_array(v_droplet_x, v_max_droplets, numeric)
create_array(v_droplet_y, v_max_droplets, numeric)
create_array(v_droplet_vx, v_max_droplets, numeric)  # velocity x
create_array(v_droplet_vy, v_max_droplets, numeric)  # velocity y
create_array(v_droplet_radius, v_max_droplets, numeric)
create_array(v_droplet_active, v_max_droplets, numeric)  # 1 = active, 0 = inactive
create_array(v_droplet_surface_contact, v_max_droplets, numeric)  # 1 = touching surface
create_array(v_droplet_age, v_max_droplets, numeric)

# Initialize droplet system
v_active_droplets = 0

for v_i in (0, v_max_droplets - 1, 1)
    v_droplet_active[v_i] = 0
    v_droplet_age[v_i] = 0
endfor v_i

print("Surface Tension Simulation Starting...")
print("Phase 1: Droplet Formation and Falling")

# Define procedure to create a new droplet
def create_droplet {
    # Parameters: v_new_x, v_new_y, v_new_vx, v_new_vy, v_new_radius
    v_droplet_index = -1
    
    # Find first inactive droplet slot
    for v_i in (0, v_max_droplets - 1, 1)
        if v_droplet_active[v_i] == 0 then
            if v_droplet_index == -1 then
                v_droplet_index = v_i
            endif
        endif
    endfor v_i
    
    # Create droplet if slot available
    if v_droplet_index >= 0 then
        v_droplet_x[v_droplet_index] = v_new_x
        v_droplet_y[v_droplet_index] = v_new_y
        v_droplet_vx[v_droplet_index] = v_new_vx
        v_droplet_vy[v_droplet_index] = v_new_vy
        v_droplet_radius[v_droplet_index] = v_new_radius
        v_droplet_active[v_droplet_index] = 1
        v_droplet_surface_contact[v_droplet_index] = 0
        v_droplet_age[v_droplet_index] = 0
        v_active_droplets = v_active_droplets + 1
    endif
}

# Define procedure to update droplet physics
def update_droplets {
    for v_i in (0, v_max_droplets - 1, 1)
        if v_droplet_active[v_i] == 1 then
            # Age the droplet
            v_droplet_age[v_i] = v_droplet_age[v_i] + 1
            
            # Apply gravity if not on surface
            if v_droplet_surface_contact[v_i] == 0 then
                v_droplet_vy[v_i] = v_droplet_vy[v_i] + v_gravity
                
                # Update position
                v_droplet_x[v_i] = v_droplet_x[v_i] + v_droplet_vx[v_i]
                v_droplet_y[v_i] = v_droplet_y[v_i] + v_droplet_vy[v_i]
                
                # Check for surface contact
                if v_droplet_y[v_i] + v_droplet_radius[v_i] >= v_surface_y then
                    v_droplet_y[v_i] = v_surface_y - v_droplet_radius[v_i]
                    v_droplet_vy[v_i] = v_droplet_vy[v_i] * -0.3  # Small bounce with energy loss
                    v_droplet_surface_contact[v_i] = 1
                    
                    # Surface tension effect - droplet spreads slightly
                    v_droplet_radius[v_i] = v_droplet_radius[v_i] + 1
                endif
            else
                # On surface - apply surface tension effects
                v_droplet_vx[v_i] = v_droplet_vx[v_i] * 0.95  # Friction
                v_droplet_x[v_i] = v_droplet_x[v_i] + v_droplet_vx[v_i]
                
                # Keep droplet on surface
                if v_droplet_y[v_i] < v_surface_y - v_droplet_radius[v_i] then
                    v_droplet_y[v_i] = v_surface_y - v_droplet_radius[v_i]
                endif
            endif
            
            # Boundary conditions
            if v_droplet_x[v_i] < v_droplet_radius[v_i] then
                v_droplet_x[v_i] = v_droplet_radius[v_i]
                v_droplet_vx[v_i] = v_droplet_vx[v_i] * -0.5
            endif
            
            if v_droplet_x[v_i] > 64 - v_droplet_radius[v_i] then
                v_droplet_x[v_i] = 64 - v_droplet_radius[v_i]
                v_droplet_vx[v_i] = v_droplet_vx[v_i] * -0.5
            endif
            
            # Remove droplet if it falls off screen
            if v_droplet_y[v_i] > 64 then
                v_droplet_active[v_i] = 0
                v_active_droplets = v_active_droplets - 1
            endif
        endif
    endfor v_i
}

# Define procedure to check and handle droplet merging
def check_merging {
    for v_i in (0, v_max_droplets - 2, 1)
        if v_droplet_active[v_i] == 1 then
            for v_j in (v_i + 1, v_max_droplets - 1, 1)
                if v_droplet_active[v_j] == 1 then
                    # Calculate distance between droplets
                    v_dx = v_droplet_x[v_i] - v_droplet_x[v_j]
                    v_dy = v_droplet_y[v_i] - v_droplet_y[v_j]
                    v_distance = sqrt(v_dx * v_dx + v_dy * v_dy)
                    v_min_merge_dist = v_droplet_radius[v_i] + v_droplet_radius[v_j] - v_merge_distance
                    
                    # Check if droplets should merge
                    if v_distance < v_min_merge_dist then
                        # Merge droplets - combine masses (radius cubed)
                        v_volume_i = v_droplet_radius[v_i] * v_droplet_radius[v_i] * v_droplet_radius[v_i]
                        v_volume_j = v_droplet_radius[v_j] * v_droplet_radius[v_j] * v_droplet_radius[v_j]
                        v_new_volume = v_volume_i + v_volume_j
                        v_new_radius = pow(v_new_volume, 1.0/3.0)
                        
                        # New position (weighted average)
                        v_total_volume = v_volume_i + v_volume_j
                        v_new_x = (v_droplet_x[v_i] * v_volume_i + v_droplet_x[v_j] * v_volume_j) / v_total_volume
                        v_new_y = (v_droplet_y[v_i] * v_volume_i + v_droplet_y[v_j] * v_volume_j) / v_total_volume
                        
                        # New velocity (conservation of momentum)
                        v_new_vx = (v_droplet_vx[v_i] * v_volume_i + v_droplet_vx[v_j] * v_volume_j) / v_total_volume
                        v_new_vy = (v_droplet_vy[v_i] * v_volume_i + v_droplet_vy[v_j] * v_volume_j) / v_total_volume
                        
                        # Update first droplet with merged properties
                        v_droplet_x[v_i] = v_new_x
                        v_droplet_y[v_i] = v_new_y
                        v_droplet_vx[v_i] = v_new_vx
                        v_droplet_vy[v_i] = v_new_vy
                        v_droplet_radius[v_i] = v_new_radius
                        
                        # Check if merged droplet is on surface
                        if v_droplet_surface_contact[v_i] == 1 or v_droplet_surface_contact[v_j] == 1 then
                            v_droplet_surface_contact[v_i] = 1
                        endif
                        
                        # Deactivate second droplet
                        v_droplet_active[v_j] = 0
                        v_active_droplets = v_active_droplets - 1
                    endif
                endif
            endfor v_j
        endif
    endfor v_i
}

# Define procedure to draw droplets with surface tension effects
def draw_droplets {
    for v_i in (0, v_max_droplets - 1, 1)
        if v_droplet_active[v_i] == 1 then
            # Calculate droplet color based on size and age
            v_blue_intensity = 60 + v_droplet_radius[v_i] * 8
            if v_blue_intensity > 100 then
                v_blue_intensity = 100
            endif
            
            # Draw droplet body
            if v_droplet_surface_contact[v_i] == 1 then
                # On surface - draw flattened droplet with surface tension curve
                v_flatten_factor = v_droplet_radius[v_i] * 0.7
                draw_ellipse(v_droplet_x[v_i], v_droplet_y[v_i], v_droplet_radius[v_i] + 1, v_flatten_factor, "cyan", v_blue_intensity, true, 0)
                
                # Surface tension meniscus effect
                draw_ellipse(v_droplet_x[v_i], v_droplet_y[v_i] + 1, v_droplet_radius[v_i], v_flatten_factor - 1, "blue", v_blue_intensity - 20, false, 0)
            else
                # In air - draw spherical droplet
                draw_circle(v_droplet_x[v_i], v_droplet_y[v_i], v_droplet_radius[v_i], "cyan", v_blue_intensity, true)
                
                # Add highlight for 3D effect
                v_highlight_x = v_droplet_x[v_i] - v_droplet_radius[v_i] / 3
                v_highlight_y = v_droplet_y[v_i] - v_droplet_radius[v_i] / 3
                plot(v_highlight_x, v_highlight_y, "white", 80)
            endif
            
            # Draw surface tension forces as small lines
            if v_droplet_surface_contact[v_i] == 1 then
                v_tension_length = v_droplet_radius[v_i] / 2
                v_left_x = v_droplet_x[v_i] - v_tension_length
                v_right_x = v_droplet_x[v_i] + v_tension_length
                v_line_y = v_droplet_y[v_i] + v_droplet_radius[v_i]
                draw_line(v_left_x, v_line_y, v_right_x, v_line_y, "white", 40)
            endif
        endif
    endfor v_i
}

# Define procedure to draw water surface
def draw_surface {
    # Water surface line
    draw_line(0, v_surface_y, 64, v_surface_y, "blue", 60)
    
    # Surface tension effects - small ripples where droplets contact
    for v_i in (0, v_max_droplets - 1, 1)
        if v_droplet_active[v_i] == 1 then
            if v_droplet_surface_contact[v_i] == 1 then
                # Small ripples around droplet contact point
                for v_ripple in (1, 3, 1)
                    v_ripple_radius = v_droplet_radius[v_i] + v_ripple * 3
                    v_ripple_intensity = 40 - v_ripple * 10
                    
                    # Only draw ripple if it's visible
                    if v_ripple_intensity > 0 then
                        for v_angle in (0, 360, 30)
                            v_ripple_x = v_droplet_x[v_i] + cos(radians(v_angle)) * v_ripple_radius
                            v_ripple_y = v_surface_y + sin(radians(v_angle)) * 2
                            
                            if v_ripple_x >= 0 then
                                if v_ripple_x < 64 then
                                    plot(v_ripple_x, v_ripple_y, "cyan", v_ripple_intensity)
                                endif
                            endif
                        endfor v_angle
                    endif
                endfor v_ripple
            endif
        endif
    endfor v_i
    
    # Draw water below surface
    draw_rectangle(0, v_surface_y + 1, 64, 64 - v_surface_y - 1, "blue", 30, true)
}

# Main simulation loop
v_frame_count = 0
v_droplet_spawn_timer = 0

print("Creating initial water droplets...")

# Create initial droplets at different positions
for v_initial in (0, 3, 1)
    v_new_x = 15 + v_initial * 15
    v_new_y = 5 + random(-3, 3, 0)
    v_new_vx = random(-1, 1, 1)
    v_new_vy = random(0, 1, 1)
    v_new_radius = 3 + random(0, 2, 0)
    
    call create_droplet
endfor v_initial

# Animation loop
for v_frame in (0, 300, 1)
    begin_frame
        # Draw surface first
        call draw_surface
        
        # Update physics
        call update_droplets
        call check_merging
        
        # Draw all droplets
        call draw_droplets
        
        # Periodically add new droplets
        v_droplet_spawn_timer = v_droplet_spawn_timer + 1
        if v_droplet_spawn_timer > 40 then
            if v_active_droplets < v_max_droplets - 2 then
                v_new_x = random(10, 54, 0)
                v_new_y = random(2, 8, 0)
                v_new_vx = random(-0.5, 0.5, 1)
                v_new_vy = 0
                v_new_radius = random(2, 4, 0)
                
                call create_droplet
                v_droplet_spawn_timer = 0
            endif
        endif
        
        # Display information
        if v_frame % 60 < 30 then
            draw_text(2, 5, f"Droplets: {v_active_droplets}", piboto-regular, 8, "white", 100)
        endif
        
        # Show different phases
        if v_frame < 100 then
            draw_text(2, 58, "Formation", piboto-regular, 8, "yellow", 80)
        elseif v_frame < 200 then
            draw_text(2, 58, "Merging", piboto-regular, 8, "yellow", 80)
        else
            draw_text(2, 58, "Equilibrium", piboto-regular, 8, "yellow", 80)
        endif
        
    end_frame
    
    rest(0.1)
    
    # Status updates
    if v_frame % 50 == 0 then
        print(f"Frame {v_frame}: {v_active_droplets} active droplets")
    endif
endfor v_frame

print("Demonstrating surface tension effects...")

# Final demonstration - create large droplets that show strong surface tension
for v_demo in (0, 3, 1)
    v_new_x = 20 + v_demo * 10
    v_new_y = 2
    v_new_vx = 0
    v_new_vy = 0
    v_new_radius = 6
    
    call create_droplet
endfor v_demo

# Show final merging effects
for v_frame in (0, 150, 1)
    begin_frame
        call draw_surface
        call update_droplets
        call check_merging
        call draw_droplets
        
        draw_text(2, 5, "Surface Tension", piboto-regular, 8, "white", 100)
        draw_text(2, 58, "Large Droplets", piboto-regular, 8, "yellow", 80)
    end_frame
    
    rest(0.15)
endfor v_frame

sync_queue
print("Surface Tension simulation complete!")
print("Observed effects:")
print("- Droplet formation and falling")
print("- Surface tension flattening") 
print("- Droplet merging with volume conservation")
print("- Meniscus effects at surface contact")
print("- Surface ripples from droplet impacts")