# 3D Wireframe Cylinder Script
# Displays a wireframe cylinder (as a 5-sided polygon) from a desk viewing angle
# With 20-degree rotation and depth-based intensity from front perspective
# Appears for 10 seconds then vanishes

# Clear display
clear()

# Set up variables for cylinder position and dimensions
v_center_x = 32   # Center X position
v_center_y = 30   # Center Y position (slightly above center for desk view)
v_radius = 15     # Radius of the cylinder
v_height = 25     # Height of the cylinder
v_sides = 5       # Number of sides for our polygon cylinder
v_top_squish = 0.4  # Vertical squish factor for perspective (top ellipse)
v_color = "cyan"  # Color of the wireframe
v_rotation = 20   # Rotation in degrees (clockwise) - shape rotation
v_shade_rotation = 90  # Additional rotation for shading calculation only

# Create arrays to store the polygon points and depth values
create_array(v_top_x, v_sides)
create_array(v_top_y, v_sides)
create_array(v_bottom_x, v_sides)
create_array(v_bottom_y, v_sides)
create_array(v_depth, v_sides)  # For storing depth values
create_array(v_draw_order, v_sides)  # For storing draw order

# Calculate the polygon points for top and bottom faces with rotation
for v_i in (0, v_sides - 1, 1)
    # Calculate the angle for this vertex (including rotation)
    v_angle = v_i * (360 / v_sides) + v_rotation
    
    # Convert angle to radians for the trig functions
    v_rad = radians(v_angle)
    
    # Calculate coordinates for top face (ellipse due to perspective)
    v_top_x[v_i] = v_center_x + cos(v_rad) * v_radius
    v_top_y[v_i] = v_center_y - v_height/2 + sin(v_rad) * v_radius * v_top_squish
    
    # Calculate coordinates for bottom face (circle with slight perspective)
    v_bottom_x[v_i] = v_center_x + cos(v_rad) * v_radius
    v_bottom_y[v_i] = v_center_y + v_height/2 + sin(v_rad) * v_radius * 0.2
    
    # Calculate depth value using the shading rotation angle (not the shape rotation)
    # This separates the visual rotation from the shading rotation
    v_shade_angle = v_i * (360 / v_sides) + v_rotation + v_shade_rotation
    v_shade_rad = radians(v_shade_angle)
    
    # Using sine function to get depth based on shading angle
    v_depth[v_i] = sin(v_shade_rad + radians(90)) * 0.5 + 0.5  # Normalize to 0-1 range
    
    # Store original index for sorting
    v_draw_order[v_i] = v_i
endfor v_i

# Simple bubble sort to order sides from back to front by depth
for v_i in (0, v_sides - 2, 1)
    for v_j in (0, v_sides - 2 - v_i, 1)
        if v_depth[v_draw_order[v_j]] > v_depth[v_draw_order[v_j + 1]] then
            # Swap
            v_temp = v_draw_order[v_j]
            v_draw_order[v_j] = v_draw_order[v_j + 1]
            v_draw_order[v_j + 1] = v_temp
        endif
    endfor v_j
endfor v_i

# Begin drawing the cylinder in a single frame
begin_frame

    # Draw from back to front based on sorted order
    for v_idx in (0, v_sides - 1, 1)
        # Get the actual side index
        v_i = v_draw_order[v_idx]
        v_next = (v_i + 1) % v_sides
        
        # Calculate intensity based on depth (farther = dimmer)
        v_intensity = 30 + v_depth[v_i] * 70  # Scale to 30-100 range
        
        # Draw vertical line for this side
        draw_line(v_top_x[v_i], v_top_y[v_i], v_bottom_x[v_i], v_bottom_y[v_i], v_color, v_intensity)
        
        # Draw top and bottom edges for this side
        draw_line(v_top_x[v_i], v_top_y[v_i], v_top_x[v_next], v_top_y[v_next], v_color, v_intensity)
        draw_line(v_bottom_x[v_i], v_bottom_y[v_i], v_bottom_x[v_next], v_bottom_y[v_next], v_color, v_intensity)
    endfor v_idx

end_frame

# Wait for 10 seconds
rest(10)

# Clear the display
clear()