# Spirograph Sequence Generator
# Creates truly randomized spirograph patterns with alternating burnout effect

# Configuration variables
v_center_x = 32          # Center X of the display (64x64)
v_center_y = 32          # Center Y of the display
v_color_num = 1          # Starting color number
v_intensity = 100        # Default intensity
v_point_delay = 0.001    # Delay between points to control drawing speed
v_max_points = 2000      # Safety limit to prevent infinite loops
v_view_time = 3          # Fixed viewing time of 3 seconds between patterns
v_pattern_count = 0      # Counter to track even/odd patterns for burnout effect

# Seed values for pseudo-random generation
v_seed1 = 42
v_seed2 = 17
v_seed3 = 31

# Create arrays for storing x,y coordinates
create_array(v_x_coords, v_max_points)
create_array(v_y_coords, v_max_points)

# Generate a better pseudo-random value
def better_random {
    # Mix multiple values for improved randomness
    v_seed1 = (v_seed1 * 75 + 13) % 100
    v_seed2 = (v_seed2 * 69 + 23) % 100
    v_seed3 = (v_seed3 * 61 + 39) % 100
    
    # Combine the seeds
    v_random_val = (v_seed1 + v_seed2 + v_seed3) % 100
}

# Get random value in range min to max
def random_in_range {
    call better_random
    v_range_size = v_max - v_min + 1
    v_result = v_min + (v_random_val % v_range_size)
}

# Drawing function
def draw_spirograph {
    # Draw the pattern point by point
    # Use different drawing commands based on pattern number
    if v_pattern_count % 2 == 1 then
        # Odd patterns - use burnout of 500ms
        #print("** Using 500ms burnout for this pattern **")
        
        for v_i in (1, v_points_needed - 1, 1) then
            v_x1 = v_x_coords[v_i - 1]
            v_y1 = v_y_coords[v_i - 1]
            v_x2 = v_x_coords[v_i]
            v_y2 = v_y_coords[v_i]
            
            # With 500ms burnout
            draw_line(v_x1, v_y1, v_x2, v_y2, v_color_num, v_intensity, 500)
            rest(v_point_delay)
        endfor v_i
        
        # Connect last point to first point
        draw_line(v_x_coords[v_points_needed - 1], v_y_coords[v_points_needed - 1], v_x_coords[0], v_y_coords[0], v_color_num, v_intensity, 500)
    else
        # Even patterns - no burnout
        for v_i in (1, v_points_needed - 1, 1) then
            v_x1 = v_x_coords[v_i - 1]
            v_y1 = v_y_coords[v_i - 1]
            v_x2 = v_x_coords[v_i]
            v_y2 = v_y_coords[v_i]
            
            # Without burnout
            draw_line(v_x1, v_y1, v_x2, v_y2, v_color_num, v_intensity)
            rest(v_point_delay)
        endfor v_i
        
        # Connect last point to first point
        draw_line(v_x_coords[v_points_needed - 1], v_y_coords[v_points_needed - 1], v_x_coords[0], v_y_coords[0], v_color_num, v_intensity)
    endif
}

# Function to create truly random patterns
def change_pattern {
    # Increment pattern counter
    v_pattern_count = v_pattern_count + 1
    
    # Clear existing pattern (only if previous pattern didn't have burnout)
    if v_pattern_count % 2 == 1 then
        clear()
    endif
    
    # Randomize outer radius (25-31)
    v_min = 25
    v_max = 31
    call random_in_range
    v_outer_radius = v_result
    
    # Use prime number differences for inner radius to create more variation
    v_min = 5
    v_max = 23
    call random_in_range
    v_inner_radius = v_result
    
    # Make sure inner radius is never equal or too close to outer radius
    if v_inner_radius >= v_outer_radius - 2 then
        v_inner_radius = v_outer_radius - 5
        if v_inner_radius < 5 then
            v_inner_radius = 5
        endif
    endif
    
    # Randomize pen distance with wider range
    v_min = 3
    v_max = v_inner_radius - 1
    if v_max < v_min then
        v_max = v_min + 1
    endif
    call random_in_range
    v_pen_distance = v_result
    
    # Randomize color with bigger jumps
    v_min = 1
    v_max = 99
    call random_in_range
    v_color_num = v_result
    
    # Add a small random offset to the center for more variation
    v_min = -2
    v_max = 2
    call random_in_range
    v_center_x_offset = v_result
    
    call random_in_range
    v_center_y_offset = v_result
    
    v_center_x = 32 + v_center_x_offset
    v_center_y = 32 + v_center_y_offset
    
    # Recalculate GCD and points - using co-prime ratios creates more interesting patterns
    v_a = v_outer_radius
    v_b = v_inner_radius
    v_temp = 0
    
    # Euclidean algorithm for GCD
    while v_b != 0 then
        v_temp = v_b
        v_b = v_a % v_b
        v_a = v_temp
    endwhile
    
    v_gcd = v_a
    
    # Handle case where GCD is 0
    if v_gcd == 0 then
        v_gcd = 1
    endif
    
    # Sometimes force a small GCD for more complex patterns
    v_min = 1
    v_max = 10
    call random_in_range
    if v_result <= 3 then
        # Force a prime-number ratio by slightly adjusting inner radius
        v_inner_radius = v_inner_radius + 1
        
        # Recalculate GCD
        v_a = v_outer_radius
        v_b = v_inner_radius
        
        while v_b != 0 then
            v_temp = v_b
            v_b = v_a % v_b
            v_a = v_temp
        endwhile
        
        v_gcd = v_a
    endif
    
    v_lcm = (v_outer_radius * v_inner_radius) / v_gcd
    v_num_rotations = v_inner_radius / v_gcd
    
    # Calculate points needed and adjust for smoother drawing
    v_points_needed = v_lcm * 120
    if v_points_needed > v_max_points then
        v_points_needed = v_max_points
    endif
    
    # Calculate theta step based on points
    v_theta_step = (2 * pi) / 120
    
    # Regenerate points
    for v_i in (0, v_points_needed - 1, 1) then
        v_theta = v_i * v_theta_step
        
        # Standard hypotrochoid equations
        v_x = v_center_x + (v_outer_radius - v_inner_radius) * cos(v_theta) + v_pen_distance * cos((v_outer_radius - v_inner_radius) * v_theta / v_inner_radius)
        v_y = v_center_y + (v_outer_radius - v_inner_radius) * sin(v_theta) - v_pen_distance * sin((v_outer_radius - v_inner_radius) * v_theta / v_inner_radius)
        
        v_x_coords[v_i] = v_x
        v_y_coords[v_i] = v_y
    endfor v_i
    
    # Draw reference circle
    draw_circle(v_center_x, v_center_y, v_outer_radius, 50, 15, false)
    
    # Display pattern information
    #print(f"Pattern #{v_pattern_count}: R={v_outer_radius}, r={v_inner_radius}, d={v_pen_distance}, color={v_color_num}")
    #print(f"Complete in {v_num_rotations} rotations with {v_points_needed} points")
    
    # Adjust seeds for next pattern
    v_seed1 = v_seed1 + v_outer_radius
    v_seed2 = v_seed2 + v_inner_radius 
    v_seed3 = v_seed3 + v_color_num
}

# Initial clear
clear()

# Infinite loop to keep generating patterns
while 1 == 1 then
    call change_pattern
    call draw_spirograph
    rest(v_view_time)  # Display each pattern for fixed time (3 seconds)
    clear()
    # Force seed change even more
    v_seed1 = v_seed1 + 13
    v_seed2 = v_seed2 + 7 
    v_seed3 = v_seed3 + 23
endwhile