# Pong Game AI Simulation - Enhanced Edition
# Court size: 64x64 pixels
# Best 2 of 3 games, first to 21 points (win by 2)

# ============================================
# GAME STATE VARIABLES
# ============================================
v_p1_games = 0
v_p2_games = 0
v_game_number = 0
v_game_over = 0

# ============================================
# PADDLE AND BALL VARIABLES
# ============================================
v_paddle_height = 12
v_paddle_width = 2
v_ball_size = 2
v_center_x = 32
v_center_y = 32
v_left_score = 0
v_right_score = 0
v_center_line_segments = 8

# Speed factors
v_ball_speed = 2
v_paddle_speed = 1.7

# Paddle positions
v_left_paddle_x = 2
v_left_paddle_y = 26
v_right_paddle_x = 60
v_right_paddle_y = 26

# Ball position and direction
v_ball_x = 32
v_ball_y = 32
v_ball_dx = 1
v_ball_dy = 0

# ============================================
# SPRITE DEFINITIONS
# ============================================
define_sprite(ball, v_ball_size, v_ball_size)
    draw_rectangle(0, 0, 1, 1, white, 100, true)
endsprite

define_sprite(left_paddle, v_paddle_width, v_paddle_height)
    draw_rectangle(0, 0, 1, v_paddle_height - 1, white, 100, true)
endsprite

define_sprite(right_paddle, v_paddle_width, v_paddle_height)
    draw_rectangle(0, 0, 1, v_paddle_height - 1, white, 100, true)
endsprite

# ============================================
# TITLE SCREEN PROCEDURE
# ============================================
def show_title_screen {
    clear()
    
    # Draw "PONG" title near top
    draw_text(32, 10, "PONG", piboto-regular, 12, white, 100, NORMAL, CENTER)
    
    # Draw decorative paddles and ball in middle
    draw_rectangle(8, 28, 2, 12, white, 60, true)
    draw_rectangle(54, 28, 2, 12, white, 60, true)
    draw_rectangle(31, 33, 2, 2, white, 60, true)
    
    # Draw game wins spread out at bottom
    # P1 on left side, P2 on right side
    draw_text(16, 52, "P1:", piboto-regular, 10, white, 100, NORMAL, RIGHT)
    draw_text(18, 52, int(v_p1_games), piboto-regular, 10, white, 100, NORMAL, LEFT)
    draw_text(48, 52, "P2:", piboto-regular, 10, white, 100, NORMAL, RIGHT)
    draw_text(50, 52, int(v_p2_games), piboto-regular, 10, white, 100, NORMAL, LEFT)
    
    # Wait 5 seconds
    rest(5)
    clear()
}

# ============================================
# GAME WON SCREEN PROCEDURE
# ============================================
def show_game_won_screen {
    clear()
    
    # Show "GAME X"
    draw_text(32, 8, "MATCH", piboto-regular, 9, white, 100, NORMAL, CENTER)
    draw_text(32, 20, int(v_game_number), piboto-regular, 9, white, 100, NORMAL, CENTER)
    
    # Show winner based on who has more points
    if v_left_score > v_right_score then
        draw_text(32, 36, "P1 WINS!", piboto-regular, 12, white, 100, NORMAL, CENTER)
    endif
    if v_right_score > v_left_score then
        draw_text(32, 36, "P2 WINS!", piboto-regular, 12, white, 100, NORMAL, CENTER)
    endif
    
    # Show game series score
    draw_text(24, 52, int(v_p1_games), piboto-regular, 10, white, 100, NORMAL, RIGHT)
    draw_text(32, 52, "-", piboto-regular, 9, white, 100, NORMAL, CENTER)
    draw_text(40, 52, int(v_p2_games), piboto-regular, 10, white, 100, NORMAL, LEFT)
    
    # Wait 4 seconds
    rest(4)
    clear()
}

# ============================================
# GAME OVER SCREEN WITH 1978 FANFARE
# ============================================
def show_game_over_screen {
    clear()
    
    # Draw initial screen with everything
    begin_frame
        # Border rectangles
        draw_rectangle(0, 0, 63, 63, white, 100, false)
        draw_rectangle(2, 2, 59, 59, white, 100, false)
        
        # Winner text
        if v_p1_games == 2 then
            draw_text(32, 22, "P1 WINS!", piboto-regular, 10, white, 100, NORMAL, CENTER)
        endif
        if v_p2_games == 2 then
            draw_text(32, 22, "P2 WINS!", piboto-regular, 10, white, 100, NORMAL, CENTER)
        endif
        
        # Final score
        draw_text(24, 40, int(v_p1_games), piboto-regular, 9, white, 100, NORMAL, RIGHT)
        draw_text(32, 42, "-", piboto-regular, 9, white, 100, NORMAL, CENTER)
        draw_text(40, 40, int(v_p2_games), piboto-regular, 9, white, 100, NORMAL, LEFT)
    end_frame
    
    rest(0.5)
    
    # Flash the rectangles 10 times
    for v_flash in (1, 10, 1)
        # Rectangles OFF (draw black)
        begin_frame(true)
            draw_rectangle(0, 0, 63, 63, black, 100, false)
            draw_rectangle(2, 2, 59, 59, black, 100, false)
        end_frame
        rest(0.5)
        
        # Rectangles ON (draw white)
        begin_frame(true)
            draw_rectangle(0, 0, 63, 63, white, 100, false)
            draw_rectangle(2, 2, 59, 59, white, 100, false)
        end_frame
        rest(0.5)
    endfor v_flash
    
    # Hold with rectangles on for 1 second
    rest(2)
    
    clear()
    rest(0.8)
}

# ============================================
# DRAW COURT PROCEDURE
# ============================================
def draw_court {
    # Draw center line (dashed)
    v_segment_height = 64 / (v_center_line_segments * 2)
    for v_i in (0, v_center_line_segments - 1, 1)
        v_y_pos = v_i * v_segment_height * 2
        draw_rectangle(31, v_y_pos, 2, v_segment_height, white, 100, true)
    endfor v_i
}

# ============================================
# UPDATE SCORE DISPLAY PROCEDURE
# ============================================
def update_score {
    clear_text(16, 3)
    draw_text(16, 3, int(v_left_score), piboto-regular, 9, white, 100, NORMAL, CENTER)
    clear_text(48, 3)
    draw_text(48, 3, int(v_right_score), piboto-regular, 9, white, 100, NORMAL, CENTER)
}

# ============================================
# UPDATE PADDLES AI PROCEDURE
# ============================================
def update_paddles {
    v_left_paddle_center = v_left_paddle_y + (v_paddle_height / 2)
    v_right_paddle_center = v_right_paddle_y + (v_paddle_height / 2)
    
    # Left paddle AI
    if v_ball_dx < 0 and v_ball_y > v_left_paddle_center + 2 then
        v_left_paddle_y = v_left_paddle_y + v_paddle_speed
        move_sprite(left_paddle, v_left_paddle_x, v_left_paddle_y)
    endif
    if v_ball_dx < 0 and v_ball_y < v_left_paddle_center - 2 then
        v_left_paddle_y = v_left_paddle_y - v_paddle_speed
        move_sprite(left_paddle, v_left_paddle_x, v_left_paddle_y)
    endif
    
    # Right paddle AI
    if v_ball_dx > 0 and v_ball_y > v_right_paddle_center + 2 then
        v_right_paddle_y = v_right_paddle_y + v_paddle_speed
        move_sprite(right_paddle, v_right_paddle_x, v_right_paddle_y)
    endif
    if v_ball_dx > 0 and v_ball_y < v_right_paddle_center - 2 then
        v_right_paddle_y = v_right_paddle_y - v_paddle_speed
        move_sprite(right_paddle, v_right_paddle_x, v_right_paddle_y)
    endif
    
    # Keep paddles in bounds
    if v_left_paddle_y < 0 then
        v_left_paddle_y = 0
        move_sprite(left_paddle, v_left_paddle_x, v_left_paddle_y)
    endif
    if v_left_paddle_y > 64 - v_paddle_height then
        v_left_paddle_y = 64 - v_paddle_height
        move_sprite(left_paddle, v_left_paddle_x, v_left_paddle_y)
    endif
    if v_right_paddle_y < 0 then
        v_right_paddle_y = 0
        move_sprite(right_paddle, v_right_paddle_x, v_right_paddle_y)
    endif
    if v_right_paddle_y > 64 - v_paddle_height then
        v_right_paddle_y = 64 - v_paddle_height
        move_sprite(right_paddle, v_right_paddle_x, v_right_paddle_y)
    endif
}

# ============================================
# CHECK COLLISIONS PROCEDURE
# ============================================
def check_collisions {
    # Ball hitting top or bottom
    if v_ball_y <= 0 then
        v_ball_dy = 1
    endif
    if v_ball_y >= 62 then
        v_ball_dy = -1
    endif
    
    # Ball hitting left paddle
    if v_ball_x <= v_left_paddle_x + v_paddle_width and v_ball_y >= v_left_paddle_y and v_ball_y <= v_left_paddle_y + v_paddle_height then
        v_ball_dx = 1
        v_hit_pos = (v_ball_y - v_left_paddle_y) / v_paddle_height
        v_base_angle = (v_hit_pos - 0.5) * 2
        v_random_factor = random(-20, 20, 0) / 100
        v_ball_dy = v_base_angle + v_random_factor
        if v_ball_dy > 0.8 then
            v_ball_dy = 0.8
        endif
        if v_ball_dy < -0.8 then
            v_ball_dy = -0.8
        endif
    endif
    
    # Ball hitting right paddle
    if v_ball_x >= v_right_paddle_x - v_ball_size and v_ball_y >= v_right_paddle_y and v_ball_y <= v_right_paddle_y + v_paddle_height then
        v_ball_dx = -1
        v_hit_pos = (v_ball_y - v_right_paddle_y) / v_paddle_height
        v_base_angle = (v_hit_pos - 0.5) * 2
        v_random_factor = random(-20, 20, 0) / 100
        v_ball_dy = v_base_angle + v_random_factor
        if v_ball_dy > 0.8 then
            v_ball_dy = 0.8
        endif
        if v_ball_dy < -0.8 then
            v_ball_dy = -0.8
        endif
    endif
}

# ============================================
# CHECK FOR POINT SCORED PROCEDURE
# ============================================
def check_scoring {
    v_point_scored = 0
    v_server = 0
    
    # Ball passed left side - P2 (right) scores
    if v_ball_x <= 0 then
        v_right_score = v_right_score + 1
        v_point_scored = 1
        v_server = 2
    endif
    
    # Ball passed right side - P1 (left) scores
    if v_ball_x >= 63 then
        v_left_score = v_left_score + 1
        v_point_scored = 1
        v_server = 1
    endif
    
    # Handle point scored
    if v_point_scored == 1 then
        # First update the score display
        call update_score
        
        # Position ball by server's paddle for serve
        if v_server == 1 then
            # P1 scored and serves - ball by left paddle
            v_ball_x = v_left_paddle_x + v_paddle_width + 3
            v_ball_y = v_left_paddle_y + (v_paddle_height / 2)
        else
            # P2 scored and serves - ball by right paddle
            v_ball_x = v_right_paddle_x - v_ball_size - 3
            v_ball_y = v_right_paddle_y + (v_paddle_height / 2)
        endif
        
        # Move ball to serve position and show it
        move_sprite(ball, v_ball_x, v_ball_y)
        
        # Ensure everything is rendered before pause
        sync_queue
        
        # 1.5 second serve pause (ball visible by paddle)
        rest(1.5)
        
        # Set ball direction for serve (toward opponent)
        v_angle = random(-45, 45, 0)
        if v_angle == 0 then
            v_angle = 15
        endif
        v_ball_dy = v_angle / 45
        
        if v_server == 1 then
            v_ball_dx = 1
        else
            v_ball_dx = -1
        endif
    endif
}

# ============================================
# CHECK FOR GAME WIN (21 pts, win by 2)
# ============================================
def check_game_win {
    v_game_won = 0
    
    # Check if left player won
    if v_left_score >= 21 then
        v_lead = v_left_score - v_right_score
        if v_lead >= 2 then
            v_game_won = 1
            v_p1_games = v_p1_games + 1
        endif
    endif
    
    # Check if right player won
    if v_right_score >= 21 then
        v_lead = v_right_score - v_left_score
        if v_lead >= 2 then
            v_game_won = 1
            v_p2_games = v_p2_games + 1
        endif
    endif
    
    # Handle game win
    if v_game_won == 1 then
        v_playing_game = 0
        
        # Hide sprites before showing game won screen
        hide_sprite(ball)
        hide_sprite(left_paddle)
        hide_sprite(right_paddle)
        
        # Check if someone won the match (2 games)
        if v_p1_games == 2 or v_p2_games == 2 then
            v_game_over = 1
        endif
        
        # Show appropriate screen
        if v_game_over == 1 then
            call show_game_over_screen
        else
            call show_game_won_screen
        endif
    endif
}

# ============================================
# UPDATE BALL POSITION PROCEDURE
# ============================================
def update_ball {
    v_ball_x = v_ball_x + (v_ball_dx * v_ball_speed)
    v_ball_y = v_ball_y + (v_ball_dy * v_ball_speed)
    move_sprite(ball, v_ball_x, v_ball_y)
}

# ============================================
# RESET FOR NEW GAME PROCEDURE
# ============================================
def reset_game {
    v_left_score = 0
    v_right_score = 0
    v_left_paddle_y = 26
    v_right_paddle_y = 26
    v_ball_x = 32
    v_ball_y = 32
    
    # Random initial direction
    v_direction = random(0, 1, 0)
    if v_direction == 0 then
        v_ball_dx = -1
    else
        v_ball_dx = 1
    endif
    
    v_angle = random(-45, 45, 0)
    if v_angle == 0 then
        v_angle = 15
    endif
    v_ball_dy = v_angle / 45
}

# ============================================
# PLAY ONE GAME PROCEDURE
# ============================================
def play_game {
    v_game_number = v_game_number + 1
    
    # Reset game state
    call reset_game
    
    # Draw court and show sprites
    clear()
    call draw_court
    show_sprite(ball, v_ball_x, v_ball_y)
    show_sprite(left_paddle, v_left_paddle_x, v_left_paddle_y)
    show_sprite(right_paddle, v_right_paddle_x, v_right_paddle_y)
    call update_score
    
    # Game loop
    v_playing_game = 1
    while v_playing_game == 1 then
        begin_frame(true)
        call update_paddles
        call update_ball
        call check_collisions
        end_frame
        
        # Check scoring AFTER frame is rendered so pause shows correctly
        call check_scoring
        call check_game_win
        
        rest(0.02)
    endwhile
}

# ============================================
# MAIN GAME LOOP
# ============================================

# Outer loop - keeps playing best-of-3 series
v_running = 1
while v_running == 1 then
    # Reset for new series
    v_p1_games = 0
    v_p2_games = 0
    v_game_number = 0
    v_game_over = 0
    
    # Show title screen
    call show_title_screen
    
    # Play games until someone wins 2
    while v_p1_games < 2 and v_p2_games < 2 then
        call play_game
    endwhile
    
    # Loop back to title for next series
endwhile

# Clean up
dispose_all_sprites()
