throttle (0)
# Global configurations up top since they'll be used by all algorithms
v_intensity = 75
v_base_color = "white"
v_compare_color = "blue"
v_swap_color = "red"
v_sorted_color = "green"
v_minimum_color = "cyan"    # Color to show current minimum value being tracked
v_insert_color = "yellow"    # Color for element being inserted
v_pivot_color = "yellow"    # Color for quicksort pivot element

v_animation_speed = 0.009
v_swap_pause = 0.04
v_pause_between_sorts = 3.0
v_clear_pause = 1.0
v_repeat_delay = 4.0
v_start_paused = true

v_show_metrics = true

# Create our arrays globally since they'll be used across procedures
create_array(v_heights, 64)
create_array(v_temp, 64)
create_array(v_stack_start, 64)  # Stack for partition start points - used by quicksort
create_array(v_stack_end, 64)    # Stack for partition end points - used by quicksort


# Initialize and shuffle procedure
def initialize_array {
    # Fill array sequentially first (1-63)
    for v_i in (0, 63, 1) then
        v_heights[v_i] = v_i + 0
    endfor v_i

    # Shuffle using Fisher-Yates
    for v_i in (63, 1, -1) then
        v_rand_index = random(0, v_i, 0)
        
        v_temp[0] = v_heights[v_i]
        v_heights[v_i] = v_heights[v_rand_index]
        v_heights[v_rand_index] = v_temp[0]
    endfor v_i
    clear()
    # Draw initial state if start_paused is true
    if v_start_paused then
#        begin_frame(true)
        for v_i in (0, 63, 1) then
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
            #rest(1)
        endfor v_i
#        end_frame
        rest(1)
    endif
}

# ---------------------------------------------------------------------------------------------

def bubble_sort {
    v_comparisons = 0
    v_swaps = 0
    
    # Draw initial state
    begin_frame(true)
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
    endfor v_i
    end_frame
    
    # Outer loop: Number of passes needed
    for v_last in (63, 1, -1) then
        v_made_swap = 0
        
        # Inner loop: Compare adjacent elements
        for v_i in (0, v_last - 1, 1) then
            v_comparisons = v_comparisons + 1
            
            # Color the two elements being compared
            begin_frame(true)
            #draw_line(v_i, 0, v_i, 63, black)
            #draw_line(v_i + 1, 0, v_i + 1, 63, black)
            #draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_compare_color, v_intensity)
            #draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_compare_color, v_intensity)
            #end_frame
            
            if v_heights[v_i] > v_heights[v_i + 1] then
                v_swaps = v_swaps + 1
                v_made_swap = 1
                
                # Show swap in red
                begin_frame(true)
                #draw_line(v_i, 0, v_i, 63, black)
                #draw_line(v_i + 1, 0, v_i + 1, 63, black)
                #draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_swap_color, v_intensity)
                #draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_swap_color, v_intensity)
                #end_frame
                #rest(v_swap_pause)
                
                # Perform swap
                v_temp[0] = v_heights[v_i]
                v_heights[v_i] = v_heights[v_i + 1]
                v_heights[v_i + 1] = v_temp[0]
            endif
            
            # Return compared elements to base color
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_i + 1, 0, v_i + 1, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
            draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_base_color, v_intensity)
            end_frame
        endfor v_i
        
        # Mark the last position as sorted
        begin_frame(true)
        draw_line(v_last, 0, v_last, 63, black)
        draw_line(v_last, 63, v_last, 63 - v_heights[v_last], v_sorted_color, v_intensity)
        end_frame
        
        if v_made_swap == 0 then
            # Color remaining elements green since they're sorted
            begin_frame(true)
            for v_i in (0, v_last - 1, 1) then
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_sorted_color, v_intensity)
            endfor v_i
            end_frame
            break
        endif
    endfor v_last
    
    if v_show_metrics then
        print(f"Bubble Sort complete:")
        print(f"Comparisons: {v_comparisons}")
        print(f"Swaps: {v_swaps}")
    endif
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------

def selection_sort {
    v_comparisons = 0
    v_swaps = 0
    
    # Draw initial state
    begin_frame(true)
    for v_k in (0, 63, 1) then
        draw_line(v_k, 0, v_k, 63, black)
        draw_line(v_k, 63, v_k, 63 - v_heights[v_k], v_base_color, v_intensity)
    endfor v_k
    end_frame
    
    # Main loop
    for v_i in (0, 63, 1) then
        v_min_idx = v_i
        v_last_j = v_i  # Keep track of last position we looked at
        
        # Search for minimum element
        for v_j in (v_i + 1, 63, 1) then
            v_comparisons = v_comparisons + 1
            
            begin_frame(true)
            # Clear and recolor previous position back to base (unless it's our current min)
            if v_last_j != v_min_idx then
                draw_line(v_last_j, 0, v_last_j, 63, black)
                draw_line(v_last_j, 63, v_last_j, 63 - v_heights[v_last_j], v_base_color, v_intensity)
            endif
            
            # Draw new position in blue
            draw_line(v_j, 0, v_j, 63, black)
            draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_compare_color, v_intensity)
            
            # Keep minimum in cyan
            draw_line(v_min_idx, 0, v_min_idx, 63, black)
            draw_line(v_min_idx, 63, v_min_idx, 63 - v_heights[v_min_idx], v_minimum_color, v_intensity)
            end_frame
            
            if v_heights[v_j] < v_heights[v_min_idx] then
                v_old_min = v_min_idx
                v_min_idx = v_j
                
                # Update old minimum back to base color
                begin_frame(true)
                draw_line(v_old_min, 0, v_old_min, 63, black)
                draw_line(v_old_min, 63, v_old_min, 63 - v_heights[v_old_min], v_base_color, v_intensity)
                end_frame
            endif
            
            v_last_j = v_j
        endfor v_j
        
        # Reset the last examined position back to base color if it's not the minimum
        if v_last_j != v_min_idx then
            begin_frame(true)
            draw_line(v_last_j, 0, v_last_j, 63, black)
            draw_line(v_last_j, 63, v_last_j, 63 - v_heights[v_last_j], v_base_color, v_intensity)
            end_frame
        endif

        # If minimum isn't already at correct position, swap it
        if v_min_idx != v_i then
            v_swaps = v_swaps + 1
            
            # Show swap in red
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_min_idx, 0, v_min_idx, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_swap_color, v_intensity)
            draw_line(v_min_idx, 63, v_min_idx, 63 - v_heights[v_min_idx], v_swap_color, v_intensity)
            end_frame
            #rest(v_swap_pause)
            
            # Perform swap
            v_temp[0] = v_heights[v_i]
            v_heights[v_i] = v_heights[v_min_idx]
            v_heights[v_min_idx] = v_temp[0]
        endif
        
        # Mark current position as sorted
        begin_frame(true)
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_sorted_color, v_intensity)
        end_frame
    endfor v_i
    
    # Mark final element as sorted
    begin_frame(true)
    draw_line(62, 0, 62, 63, black)
    draw_line(62, 63, 62, 63 - v_heights[62], v_sorted_color, v_intensity)
    end_frame
    
    if v_show_metrics then
        print(f"Selection Sort complete:")
        print(f"Comparisons: {v_comparisons}")
        print(f"Swaps: {v_swaps}")
    endif
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------

def insertion_sort {
    v_comparisons = 0
    v_swaps = 0
    
    # Draw initial state
    begin_frame(true)
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
    endfor v_i
    end_frame
    
    # First element is already sorted
    begin_frame(true)
    draw_line(0, 0, 0, 63, black)
    draw_line(0, 63, 0, 63 - v_heights[0], v_sorted_color, v_intensity)
    end_frame
    
    # Start from second element
    for v_i in (1, 63, 1) then
        v_key = v_heights[v_i]
        
        # Mark element to be inserted in purple
        begin_frame(true)
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_key, v_insert_color, v_intensity)
        end_frame
        
        # First scan to find insertion point
        v_j = v_i - 1
        v_insertion_point = 0
        
        while v_j >= 0 then
            v_comparisons = v_comparisons + 1
            
            # Show element being compared in blue
            begin_frame(true)
            draw_line(v_j, 0, v_j, 63, black)
            draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_compare_color, v_intensity)
            end_frame
            
            if v_heights[v_j] <= v_key then
                v_insertion_point = v_j + 1
                v_j = -1
            else
                v_j = v_j - 1
                if v_j < 0 then
                    v_insertion_point = 0
                endif
            endif
        endwhile
        
        # Now shift everything right from insertion point to i-1
        if v_insertion_point < v_i then
            v_j = v_i
            while v_j > v_insertion_point then
                v_swaps = v_swaps + 1
                
                # Show the shift in red
                begin_frame(true)
                draw_line(v_j - 1, 0, v_j - 1, 63, black)
                draw_line(v_j, 0, v_j, 63, black)
                draw_line(v_j - 1, 63, v_j - 1, 63 - v_heights[v_j - 1], v_swap_color, v_intensity)
                draw_line(v_j, 63, v_j, 63 - v_heights[v_j - 1], v_swap_color, v_intensity)
                end_frame
                #rest(v_swap_pause)
                
                v_heights[v_j] = v_heights[v_j - 1]
                v_j = v_j - 1
            endwhile
            
            # Insert key at found position
            v_heights[v_insertion_point] = v_key
        endif
        
        # Show insertion in red
        begin_frame(true)
        draw_line(v_insertion_point, 0, v_insertion_point, 63, black)
        draw_line(v_insertion_point, 63, v_insertion_point, 63 - v_key, v_swap_color, v_intensity)
        end_frame
        #rest(v_swap_pause)
        
        # Color sorted portion green
        begin_frame(true)
        for v_k in (0, v_i, 1) then
            draw_line(v_k, 0, v_k, 63, black)
            draw_line(v_k, 63, v_k, 63 - v_heights[v_k], v_sorted_color, v_intensity)
        endfor v_k
        end_frame
    endfor v_i
    
    if v_show_metrics then
        print(f"Insertion Sort complete:")
        print(f"Comparisons: {v_comparisons}")
        print(f"Swaps: {v_swaps}")
    endif
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------

# Global variable to communicate partition point
v_partition_result = 0

def partition_section {
    v_local_partition = v_start
    
    print(f"Starting partition of section {v_start} to {v_end}")
    print(f"Initial partition index: {v_local_partition}")
    
    # Choose rightmost element in THIS SECTION as pivot
    v_pivot_pos = v_end
    v_pivot_value = v_heights[v_pivot_pos]
    print(f"Chose pivot at position {v_pivot_pos} with value {v_pivot_value}")
    
    # Show pivot in yellow
    begin_frame(true)
    draw_line(v_pivot_pos, 0, v_pivot_pos, 63, black)
    draw_line(v_pivot_pos, 63, v_pivot_pos, 63 - v_heights[v_pivot_pos], v_pivot_color, v_intensity)
    end_frame
    
    # Partition elements
    for v_j in (v_start, v_end - 1, 1) then
        v_curr_value = v_heights[v_j]
        print(f"  Comparing position {v_j} value {v_curr_value} with pivot {v_pivot_value}")
        
        begin_frame(true)
        draw_line(v_j, 0, v_j, 63, black)
        draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_compare_color, v_intensity)
        end_frame
        
        if v_heights[v_j] < v_pivot_value then
            print(f"    Found value less than pivot, swapping {v_j} with {v_local_partition}")
            
            # Show swap in red
            begin_frame(true)
            draw_line(v_local_partition, 0, v_local_partition, 63, black)
            draw_line(v_j, 0, v_j, 63, black)
            draw_line(v_local_partition, 63, v_local_partition, 63 - v_heights[v_local_partition], v_swap_color, v_intensity)
            draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_swap_color, v_intensity)
            end_frame
            
            # Perform swap
            v_temp[0] = v_heights[v_local_partition]
            v_heights[v_local_partition] = v_heights[v_j]
            v_heights[v_j] = v_temp[0]
            
            # Return swapped elements to white
            begin_frame(true)
            draw_line(v_local_partition, 0, v_local_partition, 63, black)
            draw_line(v_j, 0, v_j, 63, black)
            draw_line(v_local_partition, 63, v_local_partition, 63 - v_heights[v_local_partition], v_base_color, v_intensity)
            draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_base_color, v_intensity)
            end_frame
            
            v_local_partition = v_local_partition + 1
            print(f"    Partition index now: {v_local_partition}")
        endif
        
        # Return compared element to white if not swapped
        begin_frame(true)
        draw_line(v_j, 0, v_j, 63, black)
        draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_base_color, v_intensity)
        end_frame
    endfor v_j
    
    # Move pivot to its final position
    begin_frame(true)
    draw_line(v_local_partition, 0, v_local_partition, 63, black)
    draw_line(v_pivot_pos, 0, v_pivot_pos, 63, black)
    draw_line(v_local_partition, 63, v_local_partition, 63 - v_heights[v_local_partition], v_swap_color, v_intensity)
    draw_line(v_pivot_pos, 63, v_pivot_pos, 63 - v_heights[v_pivot_pos], v_swap_color, v_intensity)
    end_frame
    
    # Swap pivot to final position
    v_temp[0] = v_heights[v_local_partition]
    v_heights[v_local_partition] = v_heights[v_pivot_pos]
    v_heights[v_pivot_pos] = v_temp[0]
    
    # Mark pivot position as sorted
    begin_frame(true)
    draw_line(v_local_partition, 0, v_local_partition, 63, black)
    draw_line(v_local_partition, 63, v_local_partition, 63 - v_heights[v_local_partition], v_sorted_color, v_intensity)
    end_frame
    
    v_partition_result = v_local_partition
    print(f"Partition complete at {v_local_partition}")
}

def quick_sort {
   v_comparisons = 0
   v_swaps = 0
   
   # Create stack arrays for sections
   create_array(v_stack_start, 64)
   create_array(v_stack_end, 64)
   v_stack_pos = 0
   
   # Push initial section
   v_stack_start[v_stack_pos] = 0
   v_stack_end[v_stack_pos] = 63
   v_stack_pos = v_stack_pos + 1
   
   # Process sections
   while v_stack_pos > 0 then
       # Get next section
       v_stack_pos = v_stack_pos - 1
       v_start = v_stack_start[v_stack_pos]
       v_end = v_stack_end[v_stack_pos]
       
       if v_start < v_end then
           
           v_pivot_pos = int(v_end)
           v_pivot_value = v_heights[v_pivot_pos]


           # Show pivot in yellow
           begin_frame(true)
           draw_line(v_pivot_pos, 0, v_pivot_pos, 63, black)
           draw_line(v_pivot_pos, 63, v_pivot_pos, 63 - v_heights[v_pivot_pos], v_pivot_color, v_intensity)
           end_frame
           
           # Initialize partition index
           v_local_partition = v_start

            # Partition elements
            for v_j in (v_start, v_end - 1, 1) then
                v_curr_value = v_heights[v_j]
                
                begin_frame(true)
                draw_line(v_j, 0, v_j, 63, black)
                draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_compare_color, v_intensity)
                end_frame
                
                if v_heights[v_j] < v_pivot_value then

                    # Show swap in red
                    begin_frame(true)
                    draw_line(v_local_partition, 0, v_local_partition, 63, black)
                    draw_line(v_j, 0, v_j, 63, black)
                    draw_line(v_local_partition, 63, v_local_partition, 63 - v_heights[v_local_partition], v_swap_color, v_intensity)
                    draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_swap_color, v_intensity)
                    end_frame
                    
                    # Perform swap
                    v_temp[0] = v_heights[v_local_partition]
                    v_heights[v_local_partition] = v_heights[v_j]
                    v_heights[v_j] = v_temp[0]
                    # Return swapped elements to white
                    begin_frame(true)
                    draw_line(v_local_partition, 0, v_local_partition, 63, black)
                    draw_line(v_j, 0, v_j, 63, black)
                    draw_line(v_local_partition, 63, v_local_partition, 63 - v_heights[v_local_partition], v_base_color, v_intensity)
                    draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_base_color, v_intensity)
                    end_frame
                    v_local_partition = v_local_partition + 1
                endif
                
                # Return compared element to white if not swapped
                begin_frame(true)
                draw_line(v_j, 0, v_j, 63, black)
                draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_base_color, v_intensity)
                end_frame
            endfor v_j

            # Move pivot to its final position

            begin_frame(true)
            draw_line(v_local_partition, 0, v_local_partition, 63, black)
            draw_line(v_pivot_pos, 0, v_pivot_pos, 63, black)
            draw_line(v_local_partition, 63, v_local_partition, 63 - v_heights[v_local_partition], v_swap_color, v_intensity)
            draw_line(v_pivot_pos, 63, v_pivot_pos, 63 - v_heights[v_pivot_pos], v_swap_color, v_intensity)
            end_frame

            # Swap pivot to final position
            v_temp[0] = v_heights[v_local_partition]
            v_heights[v_local_partition] = v_heights[v_pivot_pos]
            v_heights[v_pivot_pos] = v_temp[0]

            # Mark pivot position as sorted

            # Explicitly color right section sorted (from pivot to end)
            begin_frame(true)
            for v_k in (v_pivot_pos, v_end, 1) then
                draw_line(v_k, 0, v_k, 63, black)
                draw_line(v_k, 63, v_k, 63 - v_heights[v_k], v_sorted_color, v_intensity)
            endfor v_k
            end_frame
            
            if v_local_partition == 63 then
                begin_frame(true)
                draw_line(v_local_partition, 0, v_local_partition, 63, black)
                draw_line(v_local_partition, 63, v_local_partition, 63 - v_heights[v_local_partition], v_sorted_color, v_intensity)
                end_frame
            else
                begin_frame(true)
                for v_k in (v_local_partition, v_local_partition + 1, 1) then
                    draw_line(v_k, 0, v_k, 63, black)
                    draw_line(v_k, 63, v_k, 63 - v_heights[v_k], v_sorted_color, v_intensity)
                endfor v_k
                end_frame
            endif

            v_partition_result = v_local_partition
            
            # Push sub-sections if they exist
            if v_local_partition - 1 > v_start then
                v_stack_start[v_stack_pos] = v_start
                v_stack_end[v_stack_pos] = v_local_partition - 1
                v_stack_pos = v_stack_pos + 1
            endif
            
            if v_end > v_local_partition + 1 then
                v_stack_start[v_stack_pos] = v_local_partition + 1
                v_stack_end[v_stack_pos] = v_end
                v_stack_pos = v_stack_pos + 1
            endif
        endif
    endwhile
    
    # Final pass - mark everything as sorted
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_sorted_color, v_intensity)
    endfor v_i
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------

def cocktail_shaker_sort {
    v_comparisons = 0
    v_swaps = 0
    
    # Draw initial state
    begin_frame(true)
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
    endfor v_i
    end_frame
    
    v_start = 0
    v_end = 63
    v_made_swap = 1
    
    while v_made_swap == 1 then
        v_made_swap = 0
        
        # Forward pass (left to right)
        for v_i in (v_start, v_end - 1, 1) then
            v_comparisons = v_comparisons + 1
            
            # Color the two elements being compared
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_i + 1, 0, v_i + 1, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_compare_color, v_intensity)
            draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_compare_color, v_intensity)
            end_frame
            
            if v_heights[v_i] > v_heights[v_i + 1] then
                v_swaps = v_swaps + 1
                v_made_swap = 1
                
                # Show swap in red
                begin_frame(true)
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i + 1, 0, v_i + 1, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_swap_color, v_intensity)
                draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_swap_color, v_intensity)
                end_frame
                #rest(v_swap_pause)
                
                # Perform swap
                v_temp[0] = v_heights[v_i]
                v_heights[v_i] = v_heights[v_i + 1]
                v_heights[v_i + 1] = v_temp[0]
            endif
            
            # Return compared elements to base color
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_i + 1, 0, v_i + 1, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
            draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_base_color, v_intensity)
            end_frame
        endfor v_i
        
        # Mark the rightmost element as sorted
        begin_frame(true)
        draw_line(v_end, 0, v_end, 63, black)
        draw_line(v_end, 63, v_end, 63 - v_heights[v_end], v_sorted_color, v_intensity)
        end_frame
        
        # If no swap occurred, array is sorted
        if v_made_swap == 0 then
            # Color remaining elements green since they're sorted
            begin_frame(true)
            for v_i in (v_start, v_end - 1, 1) then
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_sorted_color, v_intensity)
            endfor v_i
            end_frame
            break
        endif
        
        v_end = v_end - 1
        v_made_swap = 0
        
        # Backward pass (right to left)
        for v_i in (v_end - 1, v_start, -1) then
            v_comparisons = v_comparisons + 1
            
            # Color the two elements being compared
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_i + 1, 0, v_i + 1, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_compare_color, v_intensity)
            draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_compare_color, v_intensity)
            end_frame
            
            if v_heights[v_i] > v_heights[v_i + 1] then
                v_swaps = v_swaps + 1
                v_made_swap = 1
                
                # Show swap in red
                begin_frame(true)
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i + 1, 0, v_i + 1, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_swap_color, v_intensity)
                draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_swap_color, v_intensity)
                end_frame
                #rest(v_swap_pause)
                
                # Perform swap
                v_temp[0] = v_heights[v_i]
                v_heights[v_i] = v_heights[v_i + 1]
                v_heights[v_i + 1] = v_temp[0]
            endif
            
            # Return compared elements to base color
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_i + 1, 0, v_i + 1, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
            draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_base_color, v_intensity)
            end_frame
        endfor v_i
        
        # Mark the leftmost element as sorted
        begin_frame(true)
        draw_line(v_start, 0, v_start, 63, black)
        draw_line(v_start, 63, v_start, 63 - v_heights[v_start], v_sorted_color, v_intensity)
        end_frame
        
        v_start = v_start + 1
    endwhile

    # Final pass - mark everything as sorted
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_sorted_color, v_intensity)
    endfor v_i
    
    if v_show_metrics then
        print(f"Cocktail Shaker Sort complete:")
        print(f"Comparisons: {v_comparisons}")
        print(f"Swaps: {v_swaps}")
    endif
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------

def comb_sort {
    v_comparisons = 0
    v_swaps = 0
    
    # Draw initial state
    begin_frame(true)
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
    endfor v_i
    end_frame
    
    # Initialize gap to array length
    v_gap = 63
    v_shrink = 1.3  # Standard shrink factor
    v_sorted = 0
    
    while v_sorted == 0 then
        # Update gap - use floor division since we can't have fractional gaps
        v_gap = int(v_gap / v_shrink)
        if v_gap < 1 then
            v_gap = 1
        endif
        
        v_made_swap = 0
        
        # Comparison loop with current gap
        for v_i in (0, 63 - v_gap, 1) then
            v_j = v_i + v_gap
            v_comparisons = v_comparisons + 1
            
            # Color the elements being compared
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_j, 0, v_j, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_compare_color, v_intensity)
            draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_compare_color, v_intensity)
            end_frame
            
            if v_heights[v_i] > v_heights[v_j] then
                v_swaps = v_swaps + 1
                v_made_swap = 1
                
                # Show swap in red
                begin_frame(true)
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_j, 0, v_j, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_swap_color, v_intensity)
                draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_swap_color, v_intensity)
                end_frame
                #rest(v_swap_pause)
                
                # Perform swap
                v_temp[0] = v_heights[v_i]
                v_heights[v_i] = v_heights[v_j]
                v_heights[v_j] = v_temp[0]
            endif
            
            # Return compared elements to base color
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_j, 0, v_j, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
            draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_base_color, v_intensity)
            end_frame
        endfor v_i
        
        # If gap is 1 and no swaps were made, array is sorted
        if v_gap == 1 then
            if v_made_swap == 0 then
                v_sorted = 1
            endif
        endif
    endwhile
    
    # Color all elements as sorted
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_sorted_color, v_intensity)
    endfor v_i
    
    if v_show_metrics then
        print(f"Comb Sort complete:")
        print(f"Comparisons: {v_comparisons}")
        print(f"Swaps: {v_swaps}")
    endif
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------

def odd_even_sort {
    v_comparisons = 0
    v_swaps = 0
    
    # Draw initial state
    begin_frame(true)
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
    endfor v_i
    end_frame
    
    v_sorted = 0
    
    while v_sorted == 0 then
        v_made_swap = 0
        
        # Even-indexed pairs pass (0-1, 2-3, 4-5, ...)
        for v_i in (0, 62, 2) then
            v_comparisons = v_comparisons + 1
            
            # Color the pair being compared
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_i + 1, 0, v_i + 1, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_compare_color, v_intensity)
            draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_compare_color, v_intensity)
            end_frame
            
            if v_heights[v_i] > v_heights[v_i + 1] then
                v_swaps = v_swaps + 1
                v_made_swap = 1
                
                # Show swap in red
                begin_frame(true)
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i + 1, 0, v_i + 1, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_swap_color, v_intensity)
                draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_swap_color, v_intensity)
                end_frame
                #rest(v_swap_pause)
                
                # Perform swap
                v_temp[0] = v_heights[v_i]
                v_heights[v_i] = v_heights[v_i + 1]
                v_heights[v_i + 1] = v_temp[0]
            endif
            
            # Return compared elements to base color
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_i + 1, 0, v_i + 1, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
            draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_base_color, v_intensity)
            end_frame
        endfor v_i
        
        # Odd-indexed pairs pass (1-2, 3-4, 5-6, ...)
        for v_i in (1, 62, 2) then
            v_comparisons = v_comparisons + 1
            
            # Color the pair being compared
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_i + 1, 0, v_i + 1, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_compare_color, v_intensity)
            draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_compare_color, v_intensity)
            end_frame
            
            if v_heights[v_i] > v_heights[v_i + 1] then
                v_swaps = v_swaps + 1
                v_made_swap = 1
                
                # Show swap in red
                begin_frame(true)
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i + 1, 0, v_i + 1, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_swap_color, v_intensity)
                draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_swap_color, v_intensity)
                end_frame
                #rest(v_swap_pause)
                
                # Perform swap
                v_temp[0] = v_heights[v_i]
                v_heights[v_i] = v_heights[v_i + 1]
                v_heights[v_i + 1] = v_temp[0]
            endif
            
            # Return compared elements to base color
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_i + 1, 0, v_i + 1, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
            draw_line(v_i + 1, 63, v_i + 1, 63 - v_heights[v_i + 1], v_base_color, v_intensity)
            end_frame
        endfor v_i
        
        # If no swaps were made in either pass, array is sorted
        if v_made_swap == 0 then
            v_sorted = 1
        endif
    endwhile
    
    # Color all elements as sorted
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_sorted_color, v_intensity)
    endfor v_i
    
    if v_show_metrics then
        print(f"Odd-Even Sort complete:")
        print(f"Comparisons: {v_comparisons}")
        print(f"Swaps: {v_swaps}")
    endif
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------

def gnome_sort {
    v_comparisons = 0
    v_swaps = 0
    
    # Draw initial state
    begin_frame(true)
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
    endfor v_i
    end_frame
    
    # Start at position 1
    v_pos = 1
    
    while v_pos < 64 then
        if v_pos == 0 then
            v_pos = 1
        endif
        
        if v_pos > 0 then
            v_comparisons = v_comparisons + 1
            
            # Only clear and redraw the elements we're comparing
            begin_frame(true)
            # Clear and redraw current and previous elements for comparison
            draw_line(v_pos, 0, v_pos, 63, black)
            draw_line(v_pos - 1, 0, v_pos - 1, 63, black)
            draw_line(v_pos, 63, v_pos, 63 - v_heights[v_pos], v_compare_color, v_intensity)
            draw_line(v_pos - 1, 63, v_pos - 1, 63 - v_heights[v_pos - 1], v_compare_color, v_intensity)
            end_frame
            
            if v_heights[v_pos] < v_heights[v_pos - 1] then
                v_swaps = v_swaps + 1
                
                # Show swap only for involved elements
                begin_frame(true)
                draw_line(v_pos, 0, v_pos, 63, black)
                draw_line(v_pos - 1, 0, v_pos - 1, 63, black)
                draw_line(v_pos, 63, v_pos, 63 - v_heights[v_pos], v_swap_color, v_intensity)
                draw_line(v_pos - 1, 63, v_pos - 1, 63 - v_heights[v_pos - 1], v_swap_color, v_intensity)
                end_frame
                #rest(v_swap_pause)
                
                # Perform swap
                v_temp[0] = v_heights[v_pos]
                v_heights[v_pos] = v_heights[v_pos - 1]
                v_heights[v_pos - 1] = v_temp[0]
                
                # Update display for swapped elements
                begin_frame(true)
                draw_line(v_pos, 0, v_pos, 63, black)
                draw_line(v_pos - 1, 0, v_pos - 1, 63, black)
                draw_line(v_pos, 63, v_pos, 63 - v_heights[v_pos], v_base_color, v_intensity)
                draw_line(v_pos - 1, 63, v_pos - 1, 63 - v_heights[v_pos - 1], v_sorted_color, v_intensity)
                end_frame
                
                v_pos = v_pos - 1
            else
                # No swap needed, mark current section as sorted
                begin_frame(true)
                draw_line(v_pos - 1, 0, v_pos - 1, 63, black)
                draw_line(v_pos - 1, 63, v_pos - 1, 63 - v_heights[v_pos - 1], v_sorted_color, v_intensity)
                draw_line(v_pos, 0, v_pos, 63, black)
                draw_line(v_pos, 63, v_pos, 63 - v_heights[v_pos], v_base_color, v_intensity)
                end_frame
                
                v_pos = v_pos + 1
            endif
        endif
    endwhile
    
    # Mark final element as sorted
    begin_frame(true)
    draw_line(63, 0, 63, 63, black)
    draw_line(63, 63, 63, 63 - v_heights[63], v_sorted_color, v_intensity)
    end_frame
    
    if v_show_metrics then
        print(f"Gnome Sort complete:")
        print(f"Comparisons: {v_comparisons}")
        print(f"Swaps: {v_swaps}")
    endif
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------

def shell_sort {
    v_comparisons = 0
    v_swaps = 0
    
    # Draw initial state
    begin_frame(true)
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
    endfor v_i
    end_frame
    
    # Start with largest gap and work down
    v_gap = 32  # Start with N/2
    
    while v_gap > 0 then
        v_swaps_in_pass = 0  # Track swaps for this gap size
        
        # Do insertion sort for elements at gap distance
        for v_i in (v_gap, 63, 1) then
            # Compare and shift elements that are gap positions apart
            v_j = v_i
            v_swaps_in_section = 0  # Track swaps for this section
            
            while v_j >= v_gap then
                v_prev_idx = v_j - v_gap
                v_comparisons = v_comparisons + 1
                
                # Show elements being compared
                begin_frame(true)
                draw_line(v_j, 0, v_j, 63, black)
                draw_line(v_prev_idx, 0, v_prev_idx, 63, black)
                draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_compare_color, v_intensity)
                draw_line(v_prev_idx, 63, v_prev_idx, 63 - v_heights[v_prev_idx], v_compare_color, v_intensity)
                end_frame
                
                if v_heights[v_prev_idx] > v_heights[v_j] then
                    v_swaps = v_swaps + 1
                    v_swaps_in_pass = v_swaps_in_pass + 1
                    v_swaps_in_section = v_swaps_in_section + 1
                    
                    # Show swap
                    begin_frame(true)
                    draw_line(v_j, 0, v_j, 63, black)
                    draw_line(v_prev_idx, 0, v_prev_idx, 63, black)
                    draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_swap_color, v_intensity)
                    draw_line(v_prev_idx, 63, v_prev_idx, 63 - v_heights[v_prev_idx], v_swap_color, v_intensity)
                    end_frame
                    #rest(v_swap_pause)
                    
                    # Simple swap using temp variable
                    v_temp[0] = v_heights[v_j]
                    v_heights[v_j] = v_heights[v_prev_idx]
                    v_heights[v_prev_idx] = v_temp[0]
                    
                    # Return elements to base color after swap
                    begin_frame(true)
                    draw_line(v_j, 0, v_j, 63, black)
                    draw_line(v_prev_idx, 0, v_prev_idx, 63, black)
                    draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_base_color, v_intensity)
                    draw_line(v_prev_idx, 63, v_prev_idx, 63 - v_heights[v_prev_idx], v_base_color, v_intensity)
                    end_frame
                    
                    v_j = v_j - v_gap
                else
                    # No swap needed
                    begin_frame(true)
                    draw_line(v_j, 0, v_j, 63, black)
                    draw_line(v_prev_idx, 0, v_prev_idx, 63, black)
                    draw_line(v_j, 63, v_j, 63 - v_heights[v_j], v_base_color, v_intensity)
                    draw_line(v_prev_idx, 63, v_prev_idx, 63 - v_heights[v_prev_idx], v_base_color, v_intensity)
                    end_frame
                    v_j = 0  # Force exit from while loop
                endif
            endwhile
            
            # If we're on gap=1 pass and no swaps occurred in this section,
            # we can mark previous elements as sorted
            if v_gap == 1 then
                if v_swaps_in_section == 0 then
                    # Mark section up to current position as sorted
                    begin_frame(true)
                    for v_k in (0, v_i, 1) then
                        draw_line(v_k, 0, v_k, 63, black)
                        draw_line(v_k, 63, v_k, 63 - v_heights[v_k], v_sorted_color, v_intensity)
                    endfor v_k
                    end_frame
                endif
            endif
        endfor v_i
        
        # If no swaps occurred in this pass with current gap,
        # we can mark larger sections as sorted
        if v_swaps_in_pass == 0 then
            begin_frame(true)
            # Mark all checked positions as sorted
            for v_k in (0, 63, 1) then
                if v_k % v_gap == 0 then  # Only positions checked in this pass
                    draw_line(v_k, 0, v_k, 63, black)
                    draw_line(v_k, 63, v_k, 63 - v_heights[v_k], v_sorted_color, v_intensity)
                endif
            endfor v_k
            end_frame
        endif
        
        # Update gap for next pass - divide by 2
        v_gap = int(v_gap / 2)
    endwhile
    
    # Final verification - mark any remaining unsorted elements as sorted
    for v_k in (0, 63, 1) then
        draw_line(v_k, 0, v_k, 63, black)
        draw_line(v_k, 63, v_k, 63 - v_heights[v_k], v_sorted_color, v_intensity)
    endfor v_k
    
    if v_show_metrics then
        print(f"Shell Sort complete:")
        print(f"Comparisons: {v_comparisons}")
        print(f"Swaps: {v_swaps}")
    endif
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------

def pancake_sort {
    v_comparisons = 0
    v_flips = 0
    
    # Draw initial state
    begin_frame(true)
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
    endfor v_i
    end_frame
    
    # Sort from right to left (largest to smallest)
    for v_curr_size in (63, 1, -1) then
        # Find the maximum element in the unsorted portion
        v_max_idx = 0
        for v_i in (1, v_curr_size, 1) then
            v_comparisons = v_comparisons + 1
            
            # Show elements being compared
            begin_frame(true)
            draw_line(v_max_idx, 0, v_max_idx, 63, black)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_max_idx, 63, v_max_idx, 63 - v_heights[v_max_idx], v_compare_color, v_intensity)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_compare_color, v_intensity)
            end_frame
            
            if v_heights[v_i] > v_heights[v_max_idx] then
                # Return old max to base color
                begin_frame(true)
                draw_line(v_max_idx, 0, v_max_idx, 63, black)
                draw_line(v_max_idx, 63, v_max_idx, 63 - v_heights[v_max_idx], v_base_color, v_intensity)
                end_frame
                
                v_max_idx = v_i
                
                # Show new max in cyan
                begin_frame(true)
                draw_line(v_max_idx, 0, v_max_idx, 63, black)
                draw_line(v_max_idx, 63, v_max_idx, 63 - v_heights[v_max_idx], v_minimum_color, v_intensity)
                end_frame
            else
                # Return compared element to base color
                begin_frame(true)
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
                end_frame
            endif
        endfor v_i
        
        # If max element is not at the beginning, flip from 0 to max_idx
        if v_max_idx != 0 then
            v_flips = v_flips + 1
            
            # Show section to be flipped in red
            begin_frame(true)
            for v_i in (0, v_max_idx, 1) then
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_swap_color, v_intensity)
            endfor v_i
            end_frame
            #rest(v_swap_pause)
            
            # Flip first section
            v_left = 0
            v_right = v_max_idx
            while v_left < v_right then
                v_temp[0] = v_heights[v_left]
                v_heights[v_left] = v_heights[v_right]
                v_heights[v_right] = v_temp[0]
                v_left = v_left + 1
                v_right = v_right - 1
            endwhile
            
            # Show result of first flip
            begin_frame(true)
            for v_i in (0, v_max_idx, 1) then
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
            endfor v_i
            end_frame
        endif
        
        # Now flip the entire unsorted portion
        if v_curr_size != 0 then
            v_flips = v_flips + 1
            
            # Show section to be flipped in red
            begin_frame(true)
            for v_i in (0, v_curr_size, 1) then
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_swap_color, v_intensity)
            endfor v_i
            end_frame
            #rest(v_swap_pause)
            
            # Flip entire section
            v_left = 0
            v_right = v_curr_size
            while v_left < v_right then
                v_temp[0] = v_heights[v_left]
                v_heights[v_left] = v_heights[v_right]
                v_heights[v_right] = v_temp[0]
                v_left = v_left + 1
                v_right = v_right - 1
            endwhile
            
            # Show result and mark the last position as sorted
            begin_frame(true)
            for v_i in (0, v_curr_size, 1) then
                draw_line(v_i, 0, v_i, 63, black)
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
            endfor v_i
            draw_line(v_curr_size, 0, v_curr_size, 63, black)
            draw_line(v_curr_size, 63, v_curr_size, 63 - v_heights[v_curr_size], v_sorted_color, v_intensity)
            end_frame
        endif
    endfor v_curr_size
    
    # Mark any remaining elements as sorted
    begin_frame(true)
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_sorted_color, v_intensity)
    endfor v_i
    end_frame
    
    if v_show_metrics then
        print(f"Pancake Sort complete:")
        print(f"Comparisons: {v_comparisons}")
        print(f"Flips: {v_flips}")
    endif
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------

def radix_sort {
    v_comparisons = 0  # Though radix sort doesn't do direct comparisons
    v_moves = 0        # Count moves instead of swaps
    
    # Draw initial state
    begin_frame(true)
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
    endfor v_i
    end_frame
    
    # Create counting arrays for each digit (0-9)
    create_array(v_count, 10)
    create_array(v_output, 64)
    
    # Process each digit position (1s, then 10s)
    v_exp = 1  # Start with ones digit
    while v_exp <= 10 then  # Only need two passes for numbers up to 63
        # Reset count array for each digit
        for v_i in (0, 9, 1) then
            v_count[v_i] = 0
        endfor v_i
        
        # Count occurrences of each digit at current position
        for v_i in (0, 63, 1) then
            v_digit = int((v_heights[v_i] / v_exp) % 10)
            v_count[v_digit] = v_count[v_digit] + 1
            
            # Highlight number being processed
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_compare_color, v_intensity)
            end_frame
        endfor v_i
        
        # Calculate cumulative count
        for v_i in (1, 9, 1) then
            v_count[v_i] = v_count[v_i] + v_count[v_i - 1]
        endfor v_i
        
        # Build output array from right to left
        v_i = 63
        while v_i >= 0 then
            v_digit = int((v_heights[v_i] / v_exp) % 10)
            v_count[v_digit] = v_count[v_digit] - 1
            v_new_pos = v_count[v_digit]
            v_output[v_new_pos] = v_heights[v_i]
            
            # Show movement
            begin_frame(true)
            # Clear old position
            draw_line(v_i, 0, v_i, 63, black)
            # Show new position in different color
            draw_line(v_new_pos, 0, v_new_pos, 63, black)
            draw_line(v_new_pos, 63, v_new_pos, 63 - v_output[v_new_pos], v_swap_color, v_intensity)
            end_frame
            #rest(v_swap_pause)
            
            v_moves = v_moves + 1
            v_i = v_i - 1
        endwhile
        
        # Copy output back to original array
        for v_i in (0, 63, 1) then
            v_heights[v_i] = v_output[v_i]
            
            # Show updated position
            begin_frame(true)
            draw_line(v_i, 0, v_i, 63, black)
            # If this is the final pass (tens digit), mark sorted columns in green
            if v_exp > 10 then
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_sorted_color, v_intensity)
            else
                draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_base_color, v_intensity)
            endif
            end_frame
        endfor v_i
        
        # Move to next digit position
        v_exp = v_exp * 10
    endwhile
    
    # Final pass - mark everything as sorted
    for v_i in (0, 63, 1) then
        draw_line(v_i, 0, v_i, 63, black)
        draw_line(v_i, 63, v_i, 63 - v_heights[v_i], v_sorted_color, v_intensity)
    endfor v_i
    
    if v_show_metrics then
        print(f"Radix Sort complete:")
        print(f"Digit positions processed: 2")
        print(f"Elements moved: {v_moves}")
    endif
    
    rest(v_pause_between_sorts)
    clear()
    rest(v_clear_pause)
}

# ---------------------------------------------------------------------------------------------


# Main loop that keeps cycling through sorting algorithms
# Create arrays to manage sort selection
create_array(v_used_sorts, 12)  # Track which sorts have been used
create_array(v_sort_order, 12)  # Current order of sorts to run

# Variable to track how many sorts have been used in current cycle
v_sorts_used = 0
v_total_sorts = 12  # Total number of sorting algorithms

# Main loop that keeps cycling through sorting algorithms
while true then
    # If we've used all sorts, reset and create new random order
    if v_sorts_used >= v_total_sorts then
        # Reset used count
        v_sorts_used = 0
        
        # Reset used sorts tracking
        for v_i in (0, 11, 1) then
            v_used_sorts[v_i] = 0
        endfor v_i
    endif
    
    # Get next random sort
    v_selected = 0
    while v_selected == 0 then
        v_rand = random(0, 11, 0)
        if v_used_sorts[v_rand] == 0 then
            v_used_sorts[v_rand] = 1
            v_selected = 1
            v_sort_order[v_sorts_used] = v_rand
        endif
    endwhile
    
    # Show sort name based on selected number
    if v_rand == 0 then
        draw_text(2, 2, "Bubble", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 1 then
        draw_text(2, 2, "Selection", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 2 then
        draw_text(2, 2, "Insertion", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 3 then
        draw_text(2, 2, "Quick", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 4 then
        draw_text(2, 2, "Cocktail", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 5 then
        draw_text(2, 2, "Comb", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 6 then
        draw_text(2, 2, "Odd-Even", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 7 then
        draw_text(2, 2, "Gnome", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 8 then
        draw_text(2, 2, "Shell", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 9 then
        draw_text(2, 2, "Pancake", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 10 then
        draw_text(2, 2, "Radix", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    if v_rand == 11 then
        draw_text(2, 2, "Binary", piboto-regular, 12, gray, 100, SLIDE, LEFT)
    endif
    
    # Pause to show name
    rest(2)
    clear()
    
    # Initialize array for fresh sort
    call initialize_array
    
    # Run selected sort
    if v_rand == 0 then
        call bubble_sort
    endif
    if v_rand == 1 then
        call selection_sort
    endif
    if v_rand == 2 then
        call insertion_sort
    endif
    if v_rand == 3 then
        call quick_sort
    endif
    if v_rand == 4 then
        call cocktail_shaker_sort
    endif
    if v_rand == 5 then
        call comb_sort
    endif
    if v_rand == 6 then
        call odd_even_sort
    endif
    if v_rand == 7 then
        call gnome_sort
    endif
    if v_rand == 8 then
        call shell_sort
    endif
    if v_rand == 9 then
        call pancake_sort
    endif
    if v_rand == 10 then
        call radix_sort
    endif
    if v_rand == 11 then
        call binary_insertion_sort
    endif
    
    # Increment count of sorts used
    v_sorts_used = v_sorts_used + 1
    
    rest(v_repeat_delay)
endwhile
