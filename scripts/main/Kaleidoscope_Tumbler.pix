# Kaleidoscope Tumbler v2 - Optimized (Drop-in Replacement)
# Adds: per-sequence BLOOM / CONTRACT modes with soft wrap + fade-in/fade-out
# Render-only transform (keeps physics intact, preserves fluid drift)

# ============================================================
# CONFIGURABLE SETTINGS
# ============================================================
v_sequence_duration = 30
v_fade_steps = 15
v_fade_delay = 0.04
v_frame_delay = 0.001
v_max_objects = 6
v_min_objects = 2

# Motion settings
v_min_speed = 0.5
v_max_speed = 1.5

# Wedge shading colors (dim)
v_wedge_color1 = "navy"
v_wedge_color2 = "dark_gray"
v_wedge_intensity = 25

throttle(0.6)

# ============================================================
# CONSTANTS
# ============================================================
v_center_x = 32
v_center_y = 32
v_max_radius = 28

# ============================================================
# PRE-CALCULATED SEGMENT ANGLES (max 8 symmetry)
# Stored as cos/sin pairs to avoid trig in draw loop
# ============================================================
create_array(v_seg_cos, 8)
create_array(v_seg_sin, 8)
create_array(v_seg_mirror, 8)

# ============================================================
# WEDGE GEOMETRY CACHE (max 8 symmetry)
# Pre-calculated wedge boundary points at v_max_radius
# plus per-wedge arc bulge and per-wedge color
# ============================================================
create_array(v_wedge_x, 9)
create_array(v_wedge_y, 9)
create_array(v_wedge_bulge, 8)
create_array(v_wedge_color, 8, string)

# ============================================================
# OBJECT ARRAYS (max 10 objects)
# ============================================================
create_array(v_obj_x, 10)
create_array(v_obj_y, 10)
create_array(v_obj_vx, 10)
create_array(v_obj_vy, 10)
create_array(v_obj_angle, 10)
create_array(v_obj_spin, 10)
create_array(v_obj_size, 10)
create_array(v_obj_shape, 10)
create_array(v_obj_color_idx, 10)
create_array(v_obj_intensity, 10)

# Color palette array (8 colors per palette for more diversity)
create_array(v_pal_colors, 8, string)

# ============================================================
# BLOOM / CONTRACT STATE (render-only; keeps physics intact)
# ============================================================
create_array(v_obj_phase, 10)          # per-object offset [0..1)
create_array(v_obj_fade_mul, 10)       # per-object fade multiplier 0..1

v_motion_mode = 0                     # 0=OSCILLATE, 1=BLOOM, 2=CONTRACT
v_global_phase = 0.0                  # 0..1
v_phase_step = 0.008                  # bloom/contract speed (tune)
v_wrap_band_px = 10                   # fade band in pixels near center/edge (tune)
v_band = 0.20                         # derived each sequence: wrap_band_px / v_max_radius

# ============================================================
# SEQUENCE STATE
# ============================================================
v_symmetry = 6
v_num_objects = 8
v_do_spin = 0
v_do_drift = 1
v_motion_speed = 1.0
v_fade_multiplier = 100
v_wedge_angle = 60
v_wedge_angle_rad = 1.047

# ============================================================
# PROCEDURES
# ============================================================

# ------------------------------
# Pre-calculate segment trig values
# Called once per sequence when symmetry changes
# ------------------------------
def calc_segment_angles {
    v_angle_step = 360 / v_symmetry
    v_seg_cos[0] = 1
    v_seg_sin[0] = 0
    v_seg_mirror[0] = 0
    
    v_seg_angle = v_angle_step
    v_seg_cos[1] = cos(radians(v_seg_angle))
    v_seg_sin[1] = sin(radians(v_seg_angle))
    v_seg_mirror[1] = 1
    
    v_seg_angle = v_angle_step * 2
    v_seg_cos[2] = cos(radians(v_seg_angle))
    v_seg_sin[2] = sin(radians(v_seg_angle))
    v_seg_mirror[2] = 0
    
    v_seg_angle = v_angle_step * 3
    v_seg_cos[3] = cos(radians(v_seg_angle))
    v_seg_sin[3] = sin(radians(v_seg_angle))
    v_seg_mirror[3] = 1
    
    v_seg_angle = v_angle_step * 4
    v_seg_cos[4] = cos(radians(v_seg_angle))
    v_seg_sin[4] = sin(radians(v_seg_angle))
    v_seg_mirror[4] = 0
    
    v_seg_angle = v_angle_step * 5
    v_seg_cos[5] = cos(radians(v_seg_angle))
    v_seg_sin[5] = sin(radians(v_seg_angle))
    v_seg_mirror[5] = 1
    
    v_seg_angle = v_angle_step * 6
    v_seg_cos[6] = cos(radians(v_seg_angle))
    v_seg_sin[6] = sin(radians(v_seg_angle))
    v_seg_mirror[6] = 0
    
    v_seg_angle = v_angle_step * 7
    v_seg_cos[7] = cos(radians(v_seg_angle))
    v_seg_sin[7] = sin(radians(v_seg_angle))
    v_seg_mirror[7] = 1
}

# ------------------------------
# Pre-calculate wedge boundary points + arc bulges at v_max_radius
# Called once per sequence (after v_symmetry and v_wedge_angle are set)
# Removes trig + cross-product work from the per-frame draw_wedges path
# ------------------------------
def calc_wedge_geometry {
    # Wedge endpoint cache at the outer radius
    v_wedge_x[0] = v_center_x + v_max_radius * v_seg_cos[0]
    v_wedge_y[0] = v_center_y + v_max_radius * v_seg_sin[0]
    v_wedge_x[1] = v_center_x + v_max_radius * v_seg_cos[1]
    v_wedge_y[1] = v_center_y + v_max_radius * v_seg_sin[1]
    v_wedge_x[2] = v_center_x + v_max_radius * v_seg_cos[2]
    v_wedge_y[2] = v_center_y + v_max_radius * v_seg_sin[2]
    v_wedge_x[3] = v_center_x + v_max_radius * v_seg_cos[3]
    v_wedge_y[3] = v_center_y + v_max_radius * v_seg_sin[3]
    v_wedge_x[4] = v_center_x + v_max_radius * v_seg_cos[4]
    v_wedge_y[4] = v_center_y + v_max_radius * v_seg_sin[4]
    v_wedge_x[5] = v_center_x + v_max_radius * v_seg_cos[5]
    v_wedge_y[5] = v_center_y + v_max_radius * v_seg_sin[5]
    v_wedge_x[6] = v_center_x + v_max_radius * v_seg_cos[6]
    v_wedge_y[6] = v_center_y + v_max_radius * v_seg_sin[6]
    v_wedge_x[7] = v_center_x + v_max_radius * v_seg_cos[7]
    v_wedge_y[7] = v_center_y + v_max_radius * v_seg_sin[7]

    # Close loop
    v_wedge_x[8] = v_wedge_x[0]
    v_wedge_y[8] = v_wedge_y[0]

    # Alternate wedge colors
    v_wedge_color[0] = v_wedge_color1
    v_wedge_color[1] = v_wedge_color2
    v_wedge_color[2] = v_wedge_color1
    v_wedge_color[3] = v_wedge_color2
    v_wedge_color[4] = v_wedge_color1
    v_wedge_color[5] = v_wedge_color2
    v_wedge_color[6] = v_wedge_color1
    v_wedge_color[7] = v_wedge_color2

    # Arc bulge magnitude (sagitta) for this wedge angle
    v_theta = v_wedge_angle_rad
    v_sag = v_max_radius * (1 - cos(v_theta / 2))

    # Precompute bulge sign so arcs curve OUTWARD (away from center)

    # Wedge 0
    v_x1 = v_wedge_x[0]
    v_y1 = v_wedge_y[0]
    v_x2 = v_wedge_x[1]
    v_y2 = v_wedge_y[1]
    v_dx = v_x2 - v_x1
    v_dy = v_y2 - v_y1
    v_cx = v_center_x - v_x1
    v_cy = v_center_y - v_y1
    v_cross = v_dx * v_cy - v_dy * v_cx
    if v_cross > 0 then
        v_wedge_bulge[0] = -v_sag
    else
        v_wedge_bulge[0] = v_sag
    endif

    # Wedge 1
    v_x1 = v_wedge_x[1]
    v_y1 = v_wedge_y[1]
    v_x2 = v_wedge_x[2]
    v_y2 = v_wedge_y[2]
    v_dx = v_x2 - v_x1
    v_dy = v_y2 - v_y1
    v_cx = v_center_x - v_x1
    v_cy = v_center_y - v_y1
    v_cross = v_dx * v_cy - v_dy * v_cx
    if v_cross > 0 then
        v_wedge_bulge[1] = -v_sag
    else
        v_wedge_bulge[1] = v_sag
    endif

    # Wedge 2
    v_x1 = v_wedge_x[2]
    v_y1 = v_wedge_y[2]
    v_x2 = v_wedge_x[3]
    v_y2 = v_wedge_y[3]
    v_dx = v_x2 - v_x1
    v_dy = v_y2 - v_y1
    v_cx = v_center_x - v_x1
    v_cy = v_center_y - v_y1
    v_cross = v_dx * v_cy - v_dy * v_cx
    if v_cross > 0 then
        v_wedge_bulge[2] = -v_sag
    else
        v_wedge_bulge[2] = v_sag
    endif

    # Wedge 3
    v_x1 = v_wedge_x[3]
    v_y1 = v_wedge_y[3]
    v_x2 = v_wedge_x[4]
    v_y2 = v_wedge_y[4]
    v_dx = v_x2 - v_x1
    v_dy = v_y2 - v_y1
    v_cx = v_center_x - v_x1
    v_cy = v_center_y - v_y1
    v_cross = v_dx * v_cy - v_dy * v_cx
    if v_cross > 0 then
        v_wedge_bulge[3] = -v_sag
    else
        v_wedge_bulge[3] = v_sag
    endif

    # Wedge 4
    v_x1 = v_wedge_x[4]
    v_y1 = v_wedge_y[4]
    v_x2 = v_wedge_x[5]
    v_y2 = v_wedge_y[5]
    v_dx = v_x2 - v_x1
    v_dy = v_y2 - v_y1
    v_cx = v_center_x - v_x1
    v_cy = v_center_y - v_y1
    v_cross = v_dx * v_cy - v_dy * v_cx
    if v_cross > 0 then
        v_wedge_bulge[4] = -v_sag
    else
        v_wedge_bulge[4] = v_sag
    endif

    # Wedge 5
    v_x1 = v_wedge_x[5]
    v_y1 = v_wedge_y[5]
    v_x2 = v_wedge_x[6]
    v_y2 = v_wedge_y[6]
    v_dx = v_x2 - v_x1
    v_dy = v_y2 - v_y1
    v_cx = v_center_x - v_x1
    v_cy = v_center_y - v_y1
    v_cross = v_dx * v_cy - v_dy * v_cx
    if v_cross > 0 then
        v_wedge_bulge[5] = -v_sag
    else
        v_wedge_bulge[5] = v_sag
    endif

    # Wedge 6
    v_x1 = v_wedge_x[6]
    v_y1 = v_wedge_y[6]
    v_x2 = v_wedge_x[7]
    v_y2 = v_wedge_y[7]
    v_dx = v_x2 - v_x1
    v_dy = v_y2 - v_y1
    v_cx = v_center_x - v_x1
    v_cy = v_center_y - v_y1
    v_cross = v_dx * v_cy - v_dy * v_cx
    if v_cross > 0 then
        v_wedge_bulge[6] = -v_sag
    else
        v_wedge_bulge[6] = v_sag
    endif

    # Wedge 7
    v_x1 = v_wedge_x[7]
    v_y1 = v_wedge_y[7]
    v_x2 = v_wedge_x[8]
    v_y2 = v_wedge_y[8]
    v_dx = v_x2 - v_x1
    v_dy = v_y2 - v_y1
    v_cx = v_center_x - v_x1
    v_cy = v_center_y - v_y1
    v_cross = v_dx * v_cy - v_dy * v_cx
    if v_cross > 0 then
        v_wedge_bulge[7] = -v_sag
    else
        v_wedge_bulge[7] = v_sag
    endif
}

# ------------------------------
# Draw alternating wedge backgrounds
# Uses triangles from center to edge + an outer arc
# ------------------------------
def draw_wedges {
    v_wedge_inten = v_wedge_intensity * v_fade_multiplier / 100

    for v_wi in (0, v_symmetry - 1, 1)
        v_wi2 = v_wi + 1

        v_x1 = v_wedge_x[v_wi]
        v_y1 = v_wedge_y[v_wi]
        v_x2 = v_wedge_x[v_wi2]
        v_y2 = v_wedge_y[v_wi2]
        v_color = v_wedge_color[v_wi]

        draw_line(v_center_x, v_center_y, v_x1, v_y1, v_color, v_wedge_inten)
        draw_line(v_center_x, v_center_y, v_x2, v_y2, v_color, v_wedge_inten)
        draw_arc(v_x1, v_y1, v_x2, v_y2, v_wedge_bulge[v_wi], v_color, v_wedge_inten, false)
    endfor v_wi
}

# ------------------------------
# Set up a color palette (8 colors, 10 palette options)
# ------------------------------
def setup_palette {
    v_pal_pick = random(1, 10, 0)
    
    # Default: Rainbow
    v_pal_colors[0] = "red"
    v_pal_colors[1] = "orange"
    v_pal_colors[2] = "yellow"
    v_pal_colors[3] = "green"
    v_pal_colors[4] = "cyan"
    v_pal_colors[5] = "blue"
    v_pal_colors[6] = "purple"
    v_pal_colors[7] = "magenta"
    
    # Palette 2: Warm sunset
    if v_pal_pick == 2 then
        v_pal_colors[0] = "red"
        v_pal_colors[1] = "orange"
        v_pal_colors[2] = "gold"
        v_pal_colors[3] = "coral"
        v_pal_colors[4] = "salmon"
        v_pal_colors[5] = "pink"
        v_pal_colors[6] = "peach"
        v_pal_colors[7] = "yellow"
    endif
    
    # Palette 3: Cool ocean
    if v_pal_pick == 3 then
        v_pal_colors[0] = "blue"
        v_pal_colors[1] = "cyan"
        v_pal_colors[2] = "teal"
        v_pal_colors[3] = "sky_blue"
        v_pal_colors[4] = "azure"
        v_pal_colors[5] = "turquoise"
        v_pal_colors[6] = "ocean_blue"
        v_pal_colors[7] = "navy"
    endif
    
    # Palette 4: Purple gold complement
    if v_pal_pick == 4 then
        v_pal_colors[0] = "purple"
        v_pal_colors[1] = "violet"
        v_pal_colors[2] = "gold"
        v_pal_colors[3] = "orange"
        v_pal_colors[4] = "magenta"
        v_pal_colors[5] = "lavender"
        v_pal_colors[6] = "yellow"
        v_pal_colors[7] = "indigo"
    endif
    
    # Palette 5: Forest nature
    if v_pal_pick == 5 then
        v_pal_colors[0] = "green"
        v_pal_colors[1] = "forest_green"
        v_pal_colors[2] = "spring_green"
        v_pal_colors[3] = "olive"
        v_pal_colors[4] = "lime"
        v_pal_colors[5] = "teal"
        v_pal_colors[6] = "mint"
        v_pal_colors[7] = "turquoise"
    endif
    
    # Palette 6: Neon electric
    if v_pal_pick == 6 then
        v_pal_colors[0] = "magenta"
        v_pal_colors[1] = "cyan"
        v_pal_colors[2] = "yellow"
        v_pal_colors[3] = "lime"
        v_pal_colors[4] = "pink"
        v_pal_colors[5] = "orange"
        v_pal_colors[6] = "violet"
        v_pal_colors[7] = "white"
    endif
    
    # Palette 7: Fire embers
    if v_pal_pick == 7 then
        v_pal_colors[0] = "red"
        v_pal_colors[1] = "orange"
        v_pal_colors[2] = "yellow"
        v_pal_colors[3] = "gold"
        v_pal_colors[4] = "crimson"
        v_pal_colors[5] = "maroon"
        v_pal_colors[6] = "coral"
        v_pal_colors[7] = "salmon"
    endif
    
    # Palette 8: Arctic ice
    if v_pal_pick == 8 then
        v_pal_colors[0] = "white"
        v_pal_colors[1] = "cyan"
        v_pal_colors[2] = "sky_blue"
        v_pal_colors[3] = "azure"
        v_pal_colors[4] = "light_gray"
        v_pal_colors[5] = "silver"
        v_pal_colors[6] = "blue"
        v_pal_colors[7] = "lavender"
    endif
    
    # Palette 9: Jewel tones
    if v_pal_pick == 9 then
        v_pal_colors[0] = "crimson"
        v_pal_colors[1] = "royal_blue"
        v_pal_colors[2] = "gold"
        v_pal_colors[3] = "purple"
        v_pal_colors[4] = "teal"
        v_pal_colors[5] = "orange"
        v_pal_colors[6] = "magenta"
        v_pal_colors[7] = "green"
    endif
    
    # Palette 10: Pastel soft
    if v_pal_pick == 10 then
        v_pal_colors[0] = "pink"
        v_pal_colors[1] = "lavender"
        v_pal_colors[2] = "peach"
        v_pal_colors[3] = "mint"
        v_pal_colors[4] = "sky_blue"
        v_pal_colors[5] = "coral"
        v_pal_colors[6] = "light_gray"
        v_pal_colors[7] = "rose"
    endif
}

# ------------------------------
# Initialize sequence parameters
# ------------------------------
def init_sequence {
    v_symmetry = random(4, 8, 0)
    v_num_objects = random(v_min_objects, v_max_objects, 0)
    
    # Calculate wedge angle for this symmetry
    v_wedge_angle = 360 / v_symmetry
    v_wedge_angle_rad = radians(v_wedge_angle)
    
    # Behavior: drift is ALWAYS on, spin is random
    v_do_drift = 1
    v_do_spin = random(0, 1, 0)
    
    v_motion_speed = random(v_min_speed * 10, v_max_speed * 10, 0) / 10.0
    
    call setup_palette
    call calc_segment_angles
    call calc_wedge_geometry

    # ------------------------------------------------
    # Motion mode per sequence: OSCILLATE / BLOOM / CONTRACT
    # (render-only; preserves physics fluidity)
    # ------------------------------------------------
    v_r = random(0, 99, 0)
    if v_r < 35 then
        v_motion_mode = 0      # OSCILLATE
    elseif v_r < 68 then
        v_motion_mode = 1      # BLOOM
    else
        v_motion_mode = 2      # CONTRACT
    endif

    # Fade band expressed in phase units (0..1)
    v_band = v_wrap_band_px / v_max_radius
    if v_band < 0.03 then
        v_band = 0.03
    endif
    if v_band > 0.35 then
        v_band = 0.35
    endif

    # Reset phase driver each sequence
    v_global_phase = 0.0

    print(f"Sequence: sym={v_symmetry} obj={v_num_objects} wedge={v_wedge_angle} drift={v_do_drift} spin={v_do_spin} speed={v_motion_speed} mode={v_motion_mode}")
}

# ------------------------------
# Initialize single object within primary wedge
# v_io_idx must be set before calling
# ------------------------------
def init_single_object {
    v_init_r = random(5, v_max_radius - 4, 0)
    v_init_angle = random(5, v_wedge_angle - 5, 0)
    v_obj_x[v_io_idx] = v_center_x + v_init_r * cos(radians(v_init_angle))
    v_obj_y[v_io_idx] = v_center_y + v_init_r * sin(radians(v_init_angle))
    
    v_obj_vx[v_io_idx] = random(-10, 10, 1) / 10.0 * v_motion_speed
    v_obj_vy[v_io_idx] = random(-10, 10, 1) / 10.0 * v_motion_speed
    
    v_obj_angle[v_io_idx] = random(0, 359, 0)
    v_obj_spin[v_io_idx] = random(-20, 20, 0) / 10.0 * v_motion_speed
    
    v_obj_size[v_io_idx] = random(2, 4, 0)
    v_obj_shape[v_io_idx] = random(1, 3, 0)
    v_obj_color_idx[v_io_idx] = random(0, 7, 0)
    v_obj_intensity[v_io_idx] = random(50, 100, 0)
}

# ------------------------------
# Initialize objects - within primary wedge
# ------------------------------
def init_objects {
    v_io_idx = 0
    call init_single_object
    v_io_idx = 1
    call init_single_object
    v_io_idx = 2
    call init_single_object
    v_io_idx = 3
    call init_single_object
    v_io_idx = 4
    call init_single_object
    v_io_idx = 5
    call init_single_object
    v_io_idx = 6
    call init_single_object
    v_io_idx = 7
    call init_single_object
    v_io_idx = 8
    call init_single_object
    v_io_idx = 9
    call init_single_object

    # Stagger bloom/contract wrap so objects never cluster/pop together
    for v_i in (0, 9, 1)
        v_obj_phase[v_i] = random(0, 1, 3)
        v_obj_fade_mul[v_i] = 1.0
    endfor v_i
}

# ------------------------------
# Update single object physics (called with v_ui set)
# ------------------------------
def update_single_object {
    if v_do_drift == 1 then
        v_obj_x[v_ui] = v_obj_x[v_ui] + v_obj_vx[v_ui]
        v_obj_y[v_ui] = v_obj_y[v_ui] + v_obj_vy[v_ui]
        
        v_bdx = v_obj_x[v_ui] - v_center_x
        v_bdy = v_obj_y[v_ui] - v_center_y
        v_dist_sq = v_bdx * v_bdx + v_bdy * v_bdy
        
        v_limit = v_max_radius - v_obj_size[v_ui]
        v_limit_sq = v_limit * v_limit
        
        if v_dist_sq > v_limit_sq then
            v_dist = sqrt(v_dist_sq)
            v_norm_x = v_bdx / v_dist
            v_norm_y = v_bdy / v_dist
            
            v_dot = v_obj_vx[v_ui] * v_norm_x + v_obj_vy[v_ui] * v_norm_y
            v_obj_vx[v_ui] = v_obj_vx[v_ui] - 2 * v_dot * v_norm_x
            v_obj_vy[v_ui] = v_obj_vy[v_ui] - 2 * v_dot * v_norm_y
            
            v_obj_x[v_ui] = v_center_x + v_norm_x * (v_limit - 1)
            v_obj_y[v_ui] = v_center_y + v_norm_y * (v_limit - 1)
            
            v_bdx = v_obj_x[v_ui] - v_center_x
            v_bdy = v_obj_y[v_ui] - v_center_y
        endif
        
        v_cur_angle = atan2(v_bdy, v_bdx)
        
        if v_cur_angle < 0 then
            v_obj_vy[v_ui] = abs(v_obj_vy[v_ui])
            v_obj_y[v_ui] = v_center_y + 1
        endif
        
        if v_cur_angle > v_wedge_angle_rad then
            v_edge_nx = sin(v_wedge_angle_rad)
            v_edge_ny = 0 - cos(v_wedge_angle_rad)
            
            v_dot = v_obj_vx[v_ui] * v_edge_nx + v_obj_vy[v_ui] * v_edge_ny
            v_obj_vx[v_ui] = v_obj_vx[v_ui] - 2 * v_dot * v_edge_nx
            v_obj_vy[v_ui] = v_obj_vy[v_ui] - 2 * v_dot * v_edge_ny
            
            v_cur_dist = sqrt(v_bdx * v_bdx + v_bdy * v_bdy)
            v_new_angle = v_wedge_angle_rad - 0.05
            v_obj_x[v_ui] = v_center_x + v_cur_dist * cos(v_new_angle)
            v_obj_y[v_ui] = v_center_y + v_cur_dist * sin(v_new_angle)
        endif
    endif
    
    if v_do_spin == 1 then
        v_obj_angle[v_ui] = v_obj_angle[v_ui] + v_obj_spin[v_ui]
    endif
}

# ------------------------------
# Update all objects
# ------------------------------
def update_objects {
    v_ui = 0
    call update_single_object
    
    if v_num_objects > 1 then
        v_ui = 1
        call update_single_object
    endif
    if v_num_objects > 2 then
        v_ui = 2
        call update_single_object
    endif
    if v_num_objects > 3 then
        v_ui = 3
        call update_single_object
    endif
    if v_num_objects > 4 then
        v_ui = 4
        call update_single_object
    endif
    if v_num_objects > 5 then
        v_ui = 5
        call update_single_object
    endif
    if v_num_objects > 6 then
        v_ui = 6
        call update_single_object
    endif
    if v_num_objects > 7 then
        v_ui = 7
        call update_single_object
    endif
    if v_num_objects > 8 then
        v_ui = 8
        call update_single_object
    endif
    if v_num_objects > 9 then
        v_ui = 9
        call update_single_object
    endif
}

# ------------------------------
# Update bloom/contract phase + per-object fade multipliers
# Render-only: does NOT affect physics positions
# ------------------------------
def update_bloom_contract {
    if v_motion_mode == 1 or v_motion_mode == 2 then
        v_global_phase = v_global_phase + v_phase_step
        if v_global_phase >= 1 then
            v_global_phase = v_global_phase - 1
        endif
    endif

    for v_i in (0, v_num_objects - 1, 1)
        v_p = v_global_phase + v_obj_phase[v_i]
        if v_p >= 1 then
            v_p = v_p - 1
        endif

        v_mul = 1.0

        if v_p < v_band then
            v_mul = v_p / v_band
        endif

        v_edge = 1 - v_band
        if v_p > v_edge then
            v_mul = (1 - v_p) / v_band
        endif

        if v_mul < 0 then
            v_mul = 0
        endif
        if v_mul > 1 then
            v_mul = 1
        endif

        v_obj_fade_mul[v_i] = v_mul
    endfor v_i
}

# ------------------------------
# Draw one object at one segment position
# v_dx, v_dy = position, v_di = object index
# ------------------------------
def draw_at_segment {
    v_col_i = v_obj_color_idx[v_di]
    v_draw_color = v_pal_colors[v_col_i]
    v_obj_inten = v_obj_intensity[v_di]
    v_draw_inten = v_obj_inten * v_fade_multiplier / 100

    if v_motion_mode == 1 or v_motion_mode == 2 then
        v_draw_inten = v_draw_inten * v_obj_fade_mul[v_di]
    endif

    v_draw_size = v_obj_size[v_di]
    v_draw_angle = v_obj_angle[v_di]
    v_draw_shape = v_obj_shape[v_di]
    
    if v_draw_shape == 1 then
        draw_circle(v_dx, v_dy, v_draw_size, v_draw_color, v_draw_inten, true)
    endif
    if v_draw_shape == 2 then
        draw_polygon(v_dx, v_dy, v_draw_size, 3, v_draw_color, v_draw_inten, v_draw_angle, true)
    endif
    if v_draw_shape == 3 then
        draw_polygon(v_dx, v_dy, v_draw_size, 6, v_draw_color, v_draw_inten, v_draw_angle, true)
    endif
}

# ------------------------------
# Draw single object across all symmetry segments
# v_di must be set to object index
# ------------------------------
def draw_object_symmetric {
    v_ox = v_obj_x[v_di]
    v_oy = v_obj_y[v_di]
    v_rel_x = v_ox - v_center_x
    v_rel_y = v_oy - v_center_y

    # Render-only bloom/contract scaling (preserves drift physics)
    v_scale = 1.0
    if v_motion_mode == 1 or v_motion_mode == 2 then
        v_p = v_global_phase + v_obj_phase[v_di]
        if v_p >= 1 then
            v_p = v_p - 1
        endif

        if v_motion_mode == 1 then
            v_scale = v_p
        else
            v_scale = 1 - v_p
        endif
    endif

    v_rel_x = v_rel_x * v_scale
    v_rel_y = v_rel_y * v_scale
    
    # Segment 0
    v_dx = v_center_x + v_rel_x
    v_dy = v_center_y + v_rel_y
    call draw_at_segment
    
    # Segment 1
    if v_symmetry > 1 then
        v_rx = v_rel_x * v_seg_cos[1] - v_rel_y * v_seg_sin[1]
        v_ry = v_rel_x * v_seg_sin[1] + v_rel_y * v_seg_cos[1]
        if v_seg_mirror[1] == 1 then
            v_ry = 0 - v_ry
        endif
        v_dx = v_center_x + v_rx
        v_dy = v_center_y + v_ry
        call draw_at_segment
    endif
    
    # Segment 2
    if v_symmetry > 2 then
        v_rx = v_rel_x * v_seg_cos[2] - v_rel_y * v_seg_sin[2]
        v_ry = v_rel_x * v_seg_sin[2] + v_rel_y * v_seg_cos[2]
        if v_seg_mirror[2] == 1 then
            v_ry = 0 - v_ry
        endif
        v_dx = v_center_x + v_rx
        v_dy = v_center_y + v_ry
        call draw_at_segment
    endif
    
    # Segment 3
    if v_symmetry > 3 then
        v_rx = v_rel_x * v_seg_cos[3] - v_rel_y * v_seg_sin[3]
        v_ry = v_rel_x * v_seg_sin[3] + v_rel_y * v_seg_cos[3]
        if v_seg_mirror[3] == 1 then
            v_ry = 0 - v_ry
        endif
        v_dx = v_center_x + v_rx
        v_dy = v_center_y + v_ry
        call draw_at_segment
    endif
    
    # Segment 4
    if v_symmetry > 4 then
        v_rx = v_rel_x * v_seg_cos[4] - v_rel_y * v_seg_sin[4]
        v_ry = v_rel_x * v_seg_sin[4] + v_rel_y * v_seg_cos[4]
        if v_seg_mirror[4] == 1 then
            v_ry = 0 - v_ry
        endif
        v_dx = v_center_x + v_rx
        v_dy = v_center_y + v_ry
        call draw_at_segment
    endif
    
    # Segment 5
    if v_symmetry > 5 then
        v_rx = v_rel_x * v_seg_cos[5] - v_rel_y * v_seg_sin[5]
        v_ry = v_rel_x * v_seg_sin[5] + v_rel_y * v_seg_cos[5]
        if v_seg_mirror[5] == 1 then
            v_ry = 0 - v_ry
        endif
        v_dx = v_center_x + v_rx
        v_dy = v_center_y + v_ry
        call draw_at_segment
    endif
    
    # Segment 6
    if v_symmetry > 6 then
        v_rx = v_rel_x * v_seg_cos[6] - v_rel_y * v_seg_sin[6]
        v_ry = v_rel_x * v_seg_sin[6] + v_rel_y * v_seg_cos[6]
        if v_seg_mirror[6] == 1 then
            v_ry = 0 - v_ry
        endif
        v_dx = v_center_x + v_rx
        v_dy = v_center_y + v_ry
        call draw_at_segment
    endif
    
    # Segment 7
    if v_symmetry > 7 then
        v_rx = v_rel_x * v_seg_cos[7] - v_rel_y * v_seg_sin[7]
        v_ry = v_rel_x * v_seg_sin[7] + v_rel_y * v_seg_cos[7]
        if v_seg_mirror[7] == 1 then
            v_ry = 0 - v_ry
        endif
        v_dx = v_center_x + v_rx
        v_dy = v_center_y + v_ry
        call draw_at_segment
    endif
}

# ------------------------------
# Draw complete frame
# ------------------------------
def draw_frame {
    begin_frame
    
    call draw_wedges
    
    v_di = 0
    call draw_object_symmetric
    
    if v_num_objects > 1 then
        v_di = 1
        call draw_object_symmetric
    endif
    if v_num_objects > 2 then
        v_di = 2
        call draw_object_symmetric
    endif
    if v_num_objects > 3 then
        v_di = 3
        call draw_object_symmetric
    endif
    if v_num_objects > 4 then
        v_di = 4
        call draw_object_symmetric
    endif
    if v_num_objects > 5 then
        v_di = 5
        call draw_object_symmetric
    endif
    if v_num_objects > 6 then
        v_di = 6
        call draw_object_symmetric
    endif
    if v_num_objects > 7 then
        v_di = 7
        call draw_object_symmetric
    endif
    if v_num_objects > 8 then
        v_di = 8
        call draw_object_symmetric
    endif
    if v_num_objects > 9 then
        v_di = 9
        call draw_object_symmetric
    endif
    
    end_frame
}

# ------------------------------
# Fade out
# ------------------------------
def fade_out {
    v_fade_multiplier = 100
    for v_fi in (1, v_fade_steps, 1)
        v_fade_multiplier = 100 - (v_fi * 100 / v_fade_steps)
        call draw_frame
        rest(v_fade_delay)
    endfor v_fi
    clear()
}

# ------------------------------
# Fade in
# ------------------------------
def fade_in {
    for v_fi in (1, v_fade_steps, 1)
        v_fade_multiplier = v_fi * 100 / v_fade_steps
        call draw_frame
        rest(v_fade_delay)
    endfor v_fi
    v_fade_multiplier = 100
}

# ============================================================
# MAIN LOOP
# ============================================================
print("Kaleidoscope Tumbler v2 starting...")

while 1 == 1 then
    call init_sequence
    call init_objects
    call fade_in
    
    v_total_frames = v_sequence_duration * 20
    
    for v_frame in (0, v_total_frames, 1)
        call update_objects
        call update_bloom_contract
        call draw_frame
        rest(v_frame_delay)
    endfor v_frame
    
    call fade_out
    print("Sequence complete...")
endwhile
